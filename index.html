<!DOCTYPE html>
<html lang="pt-BR" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>TremorPSD - Análise Aprimorada</title>
    
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Chart.js via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- jsPDF via CDN for PDF Export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- Custom Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* Estilos base e customizações */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        /* Animação de pulso para o ícone */
        @keyframes pulse-glow {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 20px 10px rgba(59, 130, 246, 0);
            }
        }
        .pulse-glow-animation {
            animation: pulse-glow 2s infinite cubic-bezier(0.4, 0, 0.6, 1);
        }
    </style>
</head>
<body class="bg-gray-900 text-white antialiased min-h-screen">

    <!-- Onboarding Screen -->
    <div id="onboarding" class="fixed inset-0 bg-gradient-to-br from-indigo-600 to-purple-700 flex flex-col justify-center items-center p-6 z-50 transition-opacity duration-500">
        <div class="bg-white/20 backdrop-blur-lg p-6 rounded-3xl mb-8">
            <svg class="w-16 h-16 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
        </div>
        <h1 class="text-4xl font-bold mb-4 text-center">Bem-vindo ao TremorPSD</h1>
        <p class="text-lg text-white/80 text-center max-w-sm mb-10">Analise tremores de forma precisa usando os sensores do seu dispositivo. Posicione o aparelho na mão ou membro a ser avaliado e siga as instruções.</p>
        <button onclick="startOnboarding()" class="bg-white text-indigo-600 font-semibold text-lg py-4 px-12 rounded-full shadow-2xl transform hover:scale-105 active:scale-95 transition-transform duration-200">
            Começar Análise
        </button>
    </div>

    <!-- Main App Container -->
    <div id="app" class="opacity-0 transition-opacity duration-500">
        <header class="bg-gray-900/70 backdrop-blur-lg sticky top-0 z-40 border-b border-gray-700/50 p-4">
            <div class="max-w-4xl mx-auto">
                <h1 class="text-xl font-bold">TremorPSD</h1>
                <p class="text-sm text-gray-400">Análise de Tremor por Densidade Espectral de Potência</p>
            </div>
        </header>

        <main class="p-4 max-w-4xl mx-auto pb-24">
            <!-- Status & Control Section -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <!-- Status Card -->
                <div id="statusCard" class="bg-gray-800 rounded-2xl p-6 border-t-4 border-blue-500 transition-all duration-300">
                    <div class="flex items-center space-x-4">
                        <div id="statusIconContainer" class="w-16 h-16 bg-gray-700 rounded-full flex items-center justify-center flex-shrink-0">
                            <div id="spinner" class="w-8 h-8 border-4 border-gray-600 border-t-blue-500 rounded-full animate-spin"></div>
                            <svg id="iconReady" class="hidden w-10 h-10 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                        </div>
                        <div>
                            <p id="statusText" class="text-lg font-semibold">Preparando sensores...</p>
                            <p id="statusDetail" class="text-sm text-gray-400">Aguarde a inicialização</p>
                        </div>
                    </div>
                </div>

                <!-- Control Panel -->
                <div class="bg-gray-800 rounded-2xl p-6">
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <label for="duration" class="text-sm text-gray-400 block mb-1">Duração (s)</label>
                            <input type="number" id="duration" value="20" min="5" max="60" class="w-full bg-gray-700 text-white rounded-lg p-2 border border-gray-600 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                        </div>
                        <div>
                            <label for="axis" class="text-sm text-gray-400 block mb-1">Eixo do Sinal</label>
                            <select id="axis" class="w-full bg-gray-700 text-white rounded-lg p-2 border border-gray-600 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                                <option value="mag">Magnitude</option>
                                <option value="x">Eixo X</option>
                                <option value="y">Eixo Y</option>
                                <option value="z">Eixo Z</option>
                            </select>
                        </div>
                    </div>
                    <button id="actionBtn" onclick="handleAction()" disabled class="w-full bg-blue-600 text-white font-semibold py-3 rounded-lg transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed hover:bg-blue-700 active:bg-blue-800 relative overflow-hidden">
                        <span id="actionText">Aguardando Sensores</span>
                        <div id="progressBar" class="absolute bottom-0 left-0 h-1 bg-white/30" style="width: 0%;"></div>
                    </button>
                </div>
            </div>

            <!-- Results Section (Initially Hidden) -->
            <div id="resultsSection" class="hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold">Resultados da Análise</h2>
                     <button onclick="showInfoModal()" class="text-blue-400 hover:text-blue-300 flex items-center space-x-1">
                         <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                         <span>O que isso significa?</span>
                     </button>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <!-- Metrics Grid -->
                    <div class="bg-gray-800 rounded-2xl p-6">
                        <h3 class="font-semibold mb-4 text-lg">Métricas de Análise</h3>
                        <div class="grid grid-cols-3 gap-4">
                            <div class="bg-gray-700/50 p-3 rounded-lg">
                                <p class="text-xs text-gray-400 truncate" title="Frequência de Pico (Peak Frequency)">Freq. de Pico</p>
                                <p id="metricPeakFreq" class="text-xl font-bold text-blue-400">— Hz</p>
                            </div>
                            <div class="bg-gray-700/50 p-3 rounded-lg">
                                <p class="text-xs text-gray-400" title="Potência Espectral Total">Potência Total</p>
                                <p id="metricTotalPower" class="text-xl font-bold text-teal-400">—</p>
                            </div>
                            <div class="bg-gray-700/50 p-3 rounded-lg">
                                <p class="text-xs text-gray-400" title="Proeminência do Pico">Proeminência</p>
                                <p id="metricProminence" class="text-xl font-bold text-cyan-400">—</p>
                            </div>
                            <div class="bg-gray-700/50 p-3 rounded-lg">
                                <p class="text-xs text-gray-400" title="Largura à Meia Altura (Full Width at Half Maximum)">FWHM</p>
                                <p id="metricFWHM" class="text-xl font-bold text-yellow-400">— Hz</p>
                            </div>
                            <div class="bg-gray-700/50 p-3 rounded-lg">
                                <p class="text-xs text-gray-400" title="Índice de Estabilidade do Tremor (Tremor Stability Index)">Estabilidade (TSI)</p>
                                <p id="metricTSI" class="text-xl font-bold text-purple-400">—</p>
                            </div>
                            <div class="bg-gray-700/50 p-3 rounded-lg">
                                <p class="text-xs text-gray-400" title="Entropia Espectral (Spectral Entropy)">Entropia Esp.</p>
                                <p id="metricEntropy" class="text-xl font-bold text-pink-400">—</p>
                            </div>
                             <div class="bg-gray-700/50 p-3 rounded-lg">
                                <p class="text-xs text-gray-400" title="Valor Quadrático Médio (Root Mean Square)">Amplitude (RMS)</p>
                                <p id="metricRMS" class="text-xl font-bold text-lime-400">—</p>
                            </div>
                            <div class="bg-gray-700/50 p-3 rounded-lg">
                                <p class="text-xs text-gray-400" title="Mediana do Jerk (50º percentil)">Jerk (JR50)</p>
                                <p id="metricJR50" class="text-xl font-bold text-red-400">—</p>
                            </div>
                            <div class="bg-gray-700/50 p-3 rounded-lg">
                                <p class="text-xs text-gray-400" title="Índice de Energia Wavelet">Índice Wavelet</p>
                                <p id="metricWavelet" class="text-xl font-bold text-indigo-400">—</p>
                            </div>
                        </div>
                    </div>
                    <!-- Classification -->
                    <div class="bg-gray-800 rounded-2xl p-6">
                        <h3 class="font-semibold mb-4 text-lg">Classificação Sugerida</h3>
                        <div class="space-y-3" id="classificationContainer">
                            <!-- Items inserted by JS -->
                        </div>
                    </div>
                </div>
                
                <!-- Charts Section -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-gray-800 rounded-2xl p-4 h-64">
                        <h3 class="font-semibold mb-2 text-center text-gray-300">Sinal no Tempo</h3>
                        <canvas id="chartTime"></canvas>
                    </div>
                    <div class="bg-gray-800 rounded-2xl p-4 h-64">
                        <h3 class="font-semibold mb-2 text-center text-gray-300">Densidade Espectral de Potência (PSD)</h3>
                        <canvas id="chartPSD"></canvas>
                    </div>
                </div>
            </div>
        </main>
        
        <!-- Footer Actions -->
        <footer id="footerActions" class="hidden fixed bottom-0 left-0 right-0 bg-gray-800/80 backdrop-blur-lg border-t border-gray-700 p-2 md:p-4">
            <div class="max-w-4xl mx-auto grid grid-cols-4 gap-2 md:gap-4">
                <button onclick="exportPdf()" class="w-full bg-red-600 text-white font-semibold py-2 md:py-3 rounded-lg hover:bg-red-700 transition-colors text-xs md:text-base">Exportar PDF</button>
                <button onclick="exportMetricsCsv()" class="w-full bg-green-600 text-white font-semibold py-2 md:py-3 rounded-lg hover:bg-green-700 transition-colors text-xs md:text-base">Métricas (CSV)</button>
                <button onclick="exportRawCsv()" class="w-full bg-gray-600 text-white font-semibold py-2 md:py-3 rounded-lg hover:bg-gray-700 transition-colors text-xs md:text-base">Dados (CSV)</button>
                <button onclick="resetApp()" class="w-full bg-blue-600 text-white font-semibold py-2 md:py-3 rounded-lg hover:bg-blue-700 transition-colors text-xs md:text-base">Nova Análise</button>
            </div>
        </footer>
    </div>

    <!-- Info Modal -->
    <div id="infoModal" class="fixed inset-0 bg-black/70 flex items-center justify-center p-4 z-50 hidden" onclick="hideInfoModal(event)">
        <div class="bg-gray-800 rounded-2xl max-w-2xl w-full max-h-[80vh] overflow-y-auto p-6" id="infoModalContent">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Entendendo os Resultados</h2>
                <button onclick="hideInfoModal()" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div class="prose prose-invert prose-sm md:prose-base text-gray-300 space-y-4">
                <p>Esta análise transforma o sinal do acelerômetro (tremor) em um gráfico de **Densidade Espectral de Potência (PSD)**, que mostra quais frequências são mais intensas.</p>
                
                <div><h4 class="font-semibold text-white">Frequência de Pico (Hz)</h4><p>A frequência onde o tremor é mais forte. É o principal indicador para classificar o tipo de tremor.</p></div>
                <div><h4 class="font-semibold text-white">Amplitude (RMS)</h4><p>Mede a intensidade ou amplitude efetiva do tremor. Um valor mais alto indica um tremor de maior amplitude.</p></div>
                <div><h4 class="font-semibold text-white">Potência Total & Proeminência</h4><p><b>Potência Total</b> é a energia total do sinal de tremor. <b>Proeminência</b> mede o quão claro e distinto é o pico principal de tremor em relação ao ruído de fundo.</p></div>
                <div><h4 class="font-semibold text-white">FWHM & Estabilidade (TSI)</h4><p>Medem a regularidade do tremor. Valores baixos (pico fino) significam um tremor muito rítmico e estável.</p></div>
                <div><h4 class="font-semibold text-white">Jerk (JR50)</h4><p>Mede a "brusquidão" do movimento. Valores altos são característicos de movimentos irregulares e súbitos, como mioclonias.</p></div>
                <div><h4 class="font-semibold text-white">Entropia & Índice Wavelet</h4><p><b>Entropia</b> mede a complexidade do sinal (sinais puros têm baixa entropia). O <b>Índice Wavelet</b> avalia a consistência do tremor na sua frequência principal ao longo do tempo.</p></div>
                <div><h4 class="font-semibold text-white">Classificação Sugerida</h4><p>Com base nas características encontradas, o sistema oferece uma sugestão. <strong>Isto não é um diagnóstico</strong> e deve ser interpretado por um profissional de saúde qualificado.</p></div>
                <p class="text-xs text-gray-500 pt-4 border-t border-gray-700">A análise é feita usando o Método de Welch para calcular a PSD, uma técnica robusta para análise de sinais biológicos.</p>
            </div>
        </div>
    </div>


<script>
// --- GLOBAL STATE & CONFIG ---
const state = {
    sensorReady: false,
    collecting: false,
    data: [],
    results: null,
    sampleRate: 0,
    eventCount: 0,
    startTime: null,
};

let timeChart, psdChart;

const CLASSIFICATION_TYPES = {
    OT: { label: 'Ortostático', color: '#FBBF24' }, // amber-400
    ET: { label: 'Essencial', color: '#34D399' }, // emerald-400
    DT: { label: 'Distônico', color: '#F87171' }, // red-400
    MY: { label: 'Mioclonia', color: '#60A5FA' }, // blue-400
};


// --- INITIALIZATION & PERMISSIONS ---
window.addEventListener('load', () => {
    const isSecureContext = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
    if (!isSecureContext) {
        return;
    }
    hideOnboarding();
});

function startOnboarding() {
    const isSecureContext = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
    if (!isSecureContext) {
        const p = document.querySelector('#onboarding p');
        const btn = document.querySelector('#onboarding button');
        p.innerHTML = '<strong>Erro de Segurança:</strong> O acesso aos sensores requer um ambiente seguro (HTTPS ou localhost). Este arquivo não pode ser aberto diretamente no navegador.';
        btn.textContent = 'Entendido';
        btn.onclick = null; 
        btn.disabled = true;
        btn.classList.add('opacity-50', 'cursor-not-allowed');
        return;
    }

    requestSensorPermission().then(granted => {
        if (granted) {
            hideOnboarding();
        } else {
            document.querySelector('#onboarding p').textContent = 'A permissão para acessar os sensores foi negada. Por favor, habilite-a nas configurações do seu navegador e atualize a página.';
            document.querySelector('#onboarding button').textContent = 'Tentar Novamente';
            document.querySelector('#onboarding button').onclick = () => location.reload();
        }
    });
}

function hideOnboarding() {
    const onboardingEl = document.getElementById('onboarding');
    const appEl = document.getElementById('app');
    onboardingEl.classList.add('opacity-0', 'pointer-events-none');
    appEl.classList.remove('opacity-0');
    setTimeout(initializeApp, 500);
}

async function requestSensorPermission() {
    try {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            const permission = await DeviceMotionEvent.requestPermission();
            return permission === 'granted';
        }
        return true;
    } catch (error) {
        console.error('Error requesting sensor permission:', error);
        return false;
    }
}

function initializeApp() {
    setupMotionListener();
    initCharts();
    setTimeout(checkSensorStatus, 1500);
}

function checkSensorStatus() {
    if (state.eventCount > 0) {
        state.sensorReady = true;
        updateUI('ready');
    } else {
        updateUI('error', {
            text: 'Sensor não detectado',
            detail: 'Mova o dispositivo para ativá-lo.'
        });
    }
}

// --- UI MANAGEMENT ---
function updateUI(status, details = {}) {
    const statusCard = document.getElementById('statusCard');
    const statusIconContainer = document.getElementById('statusIconContainer');
    const spinner = document.getElementById('spinner');
    const iconReady = document.getElementById('iconReady');
    const statusText = document.getElementById('statusText');
    const statusDetail = document.getElementById('statusDetail');
    const actionBtn = document.getElementById('actionBtn');
    const actionText = document.getElementById('actionText');
    
    statusCard.className = 'bg-gray-800 rounded-2xl p-6 border-t-4 transition-all duration-300';
    statusIconContainer.classList.remove('pulse-glow-animation');
    spinner.classList.add('hidden');
    iconReady.classList.add('hidden');
    actionBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'bg-green-500');
    actionBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');

    switch (status) {
        case 'initializing':
            statusText.textContent = 'Preparando sensores...';
            statusDetail.textContent = 'Aguarde a inicialização';
            statusCard.classList.add('border-blue-500');
            spinner.classList.remove('hidden');
            actionBtn.disabled = true;
            actionText.textContent = 'Aguardando Sensores';
            break;
        case 'ready':
            statusText.textContent = 'Pronto para análise';
            statusDetail.textContent = `Taxa de amostra: ${state.sampleRate.toFixed(0)} Hz`;
            statusCard.classList.add('border-green-500');
            statusIconContainer.classList.add('pulse-glow-animation');
            iconReady.classList.remove('hidden');
            actionBtn.disabled = false;
            actionText.textContent = 'Iniciar Coleta';
            break;
        case 'collecting':
            statusText.textContent = 'Coletando dados...';
            statusCard.classList.add('border-yellow-500');
            spinner.classList.remove('hidden');
            actionBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
            actionBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
            actionText.textContent = 'Parar Coleta';
            break;
        case 'analyzing':
            statusText.textContent = 'Analisando...';
            statusDetail.textContent = `${state.data.length} amostras coletadas.`;
            statusCard.classList.add('border-purple-500');
            spinner.classList.remove('hidden');
            actionBtn.disabled = true;
            actionText.textContent = 'Processando...';
            break;
        case 'done':
            statusText.textContent = 'Análise Concluída';
            statusDetail.textContent = `Pico em ${state.results.peakFreq.toFixed(1)} Hz`;
            statusCard.classList.add('border-green-500');
            iconReady.classList.remove('hidden');
            actionBtn.disabled = true;
            actionText.textContent = 'Análise Completa';
            actionBtn.classList.add('bg-green-500');
            break;
        case 'error':
            statusText.textContent = details.text || 'Erro';
            statusDetail.textContent = details.detail || 'Tente novamente.';
            statusCard.classList.add('border-red-500');
            actionBtn.disabled = true;
            actionText.textContent = 'Erro no Sensor';
            break;
    }
}

function showInfoModal() {
    document.getElementById('infoModal').classList.remove('hidden');
}

function hideInfoModal(event) {
    if (event && event.target.id !== 'infoModal') return;
    document.getElementById('infoModal').classList.add('hidden');
}


// --- SENSOR & DATA COLLECTION ---
function setupMotionListener() {
    let lastTime = performance.now();
    
    const handleMotion = (event) => {
        state.eventCount++;
        const now = performance.now();
        const dt = (now - lastTime) / 1000;
        if (dt > 0) {
            const currentRate = 1 / dt;
            state.sampleRate = state.sampleRate * 0.95 + currentRate * 0.05;
        }
        lastTime = now;

        if (state.collecting) {
            const acc = event.accelerationIncludingGravity;
            if (!acc || acc.x === null) return;

            const t = (now - state.startTime) / 1000;
            const axis = document.getElementById('axis').value;
            let value;
            switch(axis) {
                case 'x': value = acc.x; break;
                case 'y': value = acc.y; break;
                case 'z': value = acc.z; break;
                default: value = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
            }
            state.data.push({ t, v: value });
            updateProgress();
        }
    };

    window.addEventListener('devicemotion', handleMotion, true);
}

function handleAction() {
    state.collecting ? stopCollection() : startCollection();
}

function startCollection() {
    state.data = [];
    state.collecting = true;
    state.startTime = performance.now();
    
    document.getElementById('resultsSection').classList.add('hidden');
    document.getElementById('footerActions').classList.add('hidden');
    
    updateUI('collecting');

    const duration = parseInt(document.getElementById('duration').value) * 1000;
    setTimeout(() => {
        if (state.collecting) stopCollection();
    }, duration);
}

function stopCollection() {
    state.collecting = false;
    if ('vibrate' in navigator) navigator.vibrate(100);
    
    document.getElementById('progressBar').style.width = '0%';
    updateUI('analyzing');
    
    setTimeout(analyzeData, 500);
}

function updateProgress() {
    const duration = parseInt(document.getElementById('duration').value);
    const elapsed = (performance.now() - state.startTime) / 1000;
    const progress = Math.min(100, (elapsed / duration) * 100);
    
    document.getElementById('progressBar').style.width = `${progress}%`;
    document.getElementById('statusDetail').textContent = `Restam ${(duration - elapsed).toFixed(0)}s | ${state.data.length} amostras`;
}


// --- SIGNAL PROCESSING & ANALYSIS ---
function fft(real, imag) {
    const n = real.length;
    if (n === 0) return;
    for (let i = 1, j = 0; i < n; i++) {
        let bit = n >> 1;
        for (; (j & bit) !== 0; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) {
            [real[i], real[j]] = [real[j], real[i]];
            [imag[i], imag[j]] = [imag[j], imag[i]];
        }
    }
    for (let len = 2; len <= n; len <<= 1) {
        const halfLen = len >> 1;
        const angle = -2 * Math.PI / len;
        const w_real = Math.cos(angle);
        const w_imag = Math.sin(angle);
        for (let i = 0; i < n; i += len) {
            let t_real = 1;
            let t_imag = 0;
            for (let j = 0; j < halfLen; j++) {
                const u_real = real[i + j], u_imag = imag[i + j];
                const v_real = real[i + j + halfLen] * t_real - imag[i + j + halfLen] * t_imag;
                const v_imag = real[i + j + halfLen] * t_imag + imag[i + j + halfLen] * t_real;
                real[i + j] = u_real + v_real;
                imag[i + j] = u_imag + v_imag;
                real[i + j + halfLen] = u_real - v_real;
                imag[i + j + halfLen] = u_imag - v_imag;
                [t_real, t_imag] = [t_real * w_real - t_imag * w_imag, t_real * w_imag + t_imag * w_real];
            }
        }
    }
}

function welch(signal, fs, nperseg) {
    const n = signal.length;
    nperseg = Math.min(nperseg, n);
    const noverlap = Math.floor(nperseg / 2);
    const step = nperseg - noverlap;
    
    const win = new Float64Array(nperseg);
    for (let i = 0; i < nperseg; i++) win[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (nperseg - 1)));
    const scale = 1.0 / (fs * (win.reduce((a, b) => a + b*b, 0) / nperseg));

    let psd = new Float64Array(Math.floor(nperseg / 2) + 1).fill(0);
    let numSegments = 0;

    for (let i = 0; i + nperseg <= n; i += step) {
        const segment = signal.slice(i, i + nperseg);
        let real = new Float64Array(nperseg);
        for (let j = 0; j < nperseg; j++) real[j] = segment[j] * win[j];
        let imag = new Float64Array(nperseg).fill(0);
        fft(real, imag);
        for (let j = 0; j < psd.length; j++) {
            const specVal = real[j]**2 + imag[j]**2;
            psd[j] += (j > 0 && j < psd.length - 1) ? 2 * specVal : specVal;
        }
        numSegments++;
    }

    if (numSegments > 0) psd = psd.map(v => v * scale / numSegments);
    const freqs = new Float64Array(psd.length);
    for (let i = 0; i < psd.length; i++) freqs[i] = i * fs / nperseg;
    return { freqs, psd };
}

function morletWavelet(length, frequency, sampleRate) {
    const real = new Float64Array(length);
    const imag = new Float64Array(length);
    const sigma = length / (2 * Math.PI * (frequency / (sampleRate / length)) * 2.5);
    const halfLength = Math.floor(length / 2);

    for (let i = 0; i < length; i++) {
        const t = i - halfLength;
        const gaussian = Math.exp(-(t * t) / (2 * sigma * sigma));
        const angle = 2 * Math.PI * frequency * (t / sampleRate);
        real[i] = Math.cos(angle) * gaussian;
        imag[i] = Math.sin(angle) * gaussian;
    }
    return { real, imag };
}

function convolve(signal, waveletReal) {
    const signalLen = signal.length;
    const waveletLen = waveletReal.length;
    let maxEnergy = 0;

    for (let i = 0; i <= signalLen - waveletLen; i++) {
        let energy = 0;
        for (let j = 0; j < waveletLen; j++) {
            energy += signal[i + j] * waveletReal[j];
        }
        const currentEnergy = energy * energy;
        if (currentEnergy > maxEnergy) {
            maxEnergy = currentEnergy;
        }
    }
    return maxEnergy;
}

function calculateWaveletEnergyRatio(signal, fs, peakFreq) {
    if (peakFreq < 2 || !fs) return 0;
    const waveletLength = Math.min(signal.length, Math.floor(fs));
    
    const peakWav = morletWavelet(waveletLength, peakFreq, fs);
    const peakEnergy = convolve(signal, peakWav.real);
    
    const noiseFreq = peakFreq > 10 ? 5 : 15;
    const noiseWav = morletWavelet(waveletLength, noiseFreq, fs);
    const noiseEnergy = convolve(signal, noiseWav.real);

    return peakEnergy / (peakEnergy + noiseEnergy + 1e-9);
}


function analyzeData() {
    if (state.data.length < 50) {
        updateUI('error', { text: 'Dados Insuficientes', detail: 'Colete por mais tempo.' });
        return;
    }
    const rawSignal = state.data.map(d => d.v);
    const mean = rawSignal.reduce((a, b) => a + b, 0) / rawSignal.length;
    const detrendedSignal = rawSignal.map(v => v - mean);
    
    const rms = Math.sqrt(detrendedSignal.reduce((sum, v) => sum + v * v, 0) / detrendedSignal.length);
    
    const jerkSignal = [];
    const times = state.data.map(d => d.t);
    for (let i = 1; i < detrendedSignal.length; i++) {
        const dt = times[i] - times[i - 1];
        if (dt > 0) {
            jerkSignal.push(Math.abs((detrendedSignal[i] - detrendedSignal[i - 1]) / dt));
        }
    }
    jerkSignal.sort((a, b) => a - b);
    const jr50 = jerkSignal.length > 0 ? jerkSignal[Math.floor(jerkSignal.length / 2)] : 0;
    
    const fs = state.sampleRate;
    const nperseg = Math.pow(2, Math.floor(Math.log2(fs * 2)));

    const { freqs, psd } = welch(detrendedSignal, fs, nperseg);

    let peakPower = 0, peakIdx = -1;
    for (let i = 0; i < freqs.length; i++) {
        if (freqs[i] >= 2 && freqs[i] <= 20) {
            if (psd[i] > peakPower) {
                peakPower = psd[i];
                peakIdx = i;
            }
        }
    }
    if (peakIdx === -1) {
         updateUI('error', { text: 'Pico não detectado', detail: 'O sinal de tremor pode ser muito fraco.' });
        return;
    }
    const peakFreq = freqs[peakIdx];
    const halfMax = peakPower / 2;
    let leftIdx = peakIdx, rightIdx = peakIdx;
    while (leftIdx > 0 && psd[leftIdx] > halfMax) leftIdx--;
    while (rightIdx < freqs.length - 1 && psd[rightIdx] > halfMax) rightIdx++;
    const fwhm = freqs[rightIdx] - freqs[leftIdx];

    const totalPower = psd.reduce((a, b) => a + b, 1e-12);
    
    let valley1 = Infinity, valley2 = Infinity;
    for (let i = 0; i < peakIdx; i++) if (psd[i] < valley1) valley1 = psd[i];
    for (let i = peakIdx + 1; i < psd.length; i++) if (psd[i] < valley2) valley2 = psd[i];
    const baseline = Math.min(valley1, valley2);
    const peakProminence = peakPower - baseline;

    const waveletIndex = calculateWaveletEnergyRatio(detrendedSignal, fs, peakFreq);

    const tsi = peakFreq > 0 ? fwhm / peakFreq : 0;
    const normalizedPsd = psd.map(p => p / totalPower);
    const spectralEntropy = -normalizedPsd.reduce((sum, p) => sum + (p > 0 ? p * Math.log2(p) : 0), 0);

    state.results = {
        times, rawSignal, detrendedSignal, freqs, psd, peakFreq, peakPower, fwhm, tsi, 
        spectralEntropy, sampleRate: fs, rms, jr50, totalPower, peakProminence, waveletIndex
    };

    displayResults();
    classifyTremor();
    updateUI('done');
    document.getElementById('resultsSection').classList.remove('hidden');
    document.getElementById('footerActions').classList.remove('hidden');
}


// --- RESULTS DISPLAY & CHARTS ---
function displayResults() {
    const { peakFreq, fwhm, tsi, spectralEntropy, rms, jr50, totalPower, peakProminence, waveletIndex } = state.results;

    document.getElementById('metricPeakFreq').textContent = `${peakFreq.toFixed(1)} Hz`;
    document.getElementById('metricFWHM').textContent = `${fwhm.toFixed(2)} Hz`;
    document.getElementById('metricTSI').textContent = `${tsi.toFixed(2)}`;
    document.getElementById('metricEntropy').textContent = `${spectralEntropy.toFixed(2)}`;
    document.getElementById('metricRMS').textContent = `${rms.toFixed(2)}`;
    document.getElementById('metricJR50').textContent = `${jr50.toFixed(1)}`;
    document.getElementById('metricTotalPower').textContent = `${(totalPower * 1e3).toExponential(1)}`;
    document.getElementById('metricProminence').textContent = `${(peakProminence * 1e3).toExponential(1)}`;
    document.getElementById('metricWavelet').textContent = `${waveletIndex.toFixed(2)}`;

    updateTimeSeriesChart();
    updatePsdChart();
}

function classifyTremor() {
    const { peakFreq, tsi, peakProminence, totalPower, jr50, waveletIndex } = state.results;
    let scores = { OT: 0, ET: 0, DT: 0, MY: 0 };

    const prominenceFactor = Math.min(1, peakProminence / (totalPower * 0.8 + 1e-9));
    const stabilityFactor = Math.max(0, 1 - tsi * 2.5);
    const jerkFactor = Math.min(1, jr50 / (state.sampleRate * 5 + 1e-9));
    
    if (peakFreq >= 4 && peakFreq <= 12) {
        scores.ET = (1 - Math.abs(peakFreq - 8) / 4) * stabilityFactor * prominenceFactor * waveletIndex;
    }
    if (peakFreq >= 13 && peakFreq <= 18) {
        scores.OT = (1 - Math.abs(peakFreq - 15.5) / 2.5) * Math.pow(stabilityFactor, 2) * Math.pow(prominenceFactor, 2) * waveletIndex;
    }
    
    const irregularityScore = (1 - stabilityFactor) + (1 - prominenceFactor) + jerkFactor;
    if (peakFreq >= 3 && peakFreq <= 9) {
        scores.DT = irregularityScore * 0.3 * (1 - waveletIndex);
    }
    scores.MY = irregularityScore * jerkFactor * 0.5;
    
    const total = Object.values(scores).reduce((a, b) => a + b, 1e-9);
    const container = document.getElementById('classificationContainer');
    container.innerHTML = '';

    const sortedScores = Object.entries(scores).sort(([,a],[,b]) => b-a);

    for (const [type, score] of sortedScores) {
        const pct = total > 0 ? (score / total) * 100 : 0;
        if (pct < 1) continue;
        
        const { label, color } = CLASSIFICATION_TYPES[type];
        const item = document.createElement('div');
        item.innerHTML = `
            <div class="flex justify-between items-center mb-1">
                <span class="text-sm">${label}</span>
                <span class="text-sm font-semibold">${pct.toFixed(0)}%</span>
            </div>
            <div class="w-full bg-gray-700 rounded-full h-2.5">
                <div class="h-2.5 rounded-full transition-all duration-1000 ease-out" style="width: ${pct}%; background-color: ${color};"></div>
            </div>`;
        container.appendChild(item);
    }
}

function initCharts() {
    const tickCallback = (value) => Number.isInteger(value) ? value : null;
    const commonOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: {
            x: { ticks: { color: '#9CA3AF', callback: tickCallback }, grid: { color: 'rgba(255,255,255,0.1)' } },
            y: { ticks: { color: '#9CA3AF' }, grid: { color: 'rgba(255,255,255,0.1)' } }
        }
    };

    timeChart = new Chart(document.getElementById('chartTime'), {
        type: 'line',
        data: { labels: [], datasets: [{ data: [], borderColor: '#60A5FA', borderWidth: 1.5, pointRadius: 0, tension: 0.1 }] },
        options: { ...commonOptions, scales: { ...commonOptions.scales, x: { ...commonOptions.scales.x, title: { display: true, text: 'Tempo (s)', color: '#9CA3AF' } } } }
    });
    
    psdChart = new Chart(document.getElementById('chartPSD'), {
        type: 'line',
        data: { labels: [], datasets: [{ data: [], borderColor: '#34D399', borderWidth: 2, pointRadius: 0, fill: { target: 'origin', above: 'rgba(52, 211, 153, 0.2)' } }] },
        options: { ...commonOptions, scales: { ...commonOptions.scales, x: { ...commonOptions.scales.x, title: { display: true, text: 'Frequência (Hz)', color: '#9CA3AF' }, max: 25, ticks: { ...commonOptions.scales.x.ticks, stepSize: 5 } }, y: { ...commonOptions.scales.y, title: { display: true, text: 'Potência', color: '#9CA3AF' } } } }
    });
}

function updateTimeSeriesChart() {
    const { times, detrendedSignal } = state.results;
    timeChart.data.labels = times;
    timeChart.data.datasets[0].data = detrendedSignal;
    timeChart.update('none');
}

function updatePsdChart() {
    const { freqs, psd } = state.results;
    psdChart.data.labels = freqs;
    psdChart.data.datasets[0].data = psd;
    psdChart.update('none');
}


// --- UTILITIES & APP LIFECYCLE ---
function exportRawCsv() {
    if (!state.data || state.data.length === 0) return;
    let csv = 'Time(s),Acceleration(m/s^2)\n';
    state.data.forEach(row => {
        csv += `${row.t.toFixed(6)},${row.v.toFixed(6)}\n`;
    });
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `dados_brutos_tremor_${new Date().toISOString().slice(0,10)}.csv`;
    a.click();
    URL.revokeObjectURL(url);
}

function exportMetricsCsv() {
    if (!state.results) return;
    const { peakFreq, fwhm, tsi, spectralEntropy, sampleRate, rms, jr50, totalPower, peakProminence, waveletIndex } = state.results;
    let csv = 'Metrica,Valor,Unidade\n';
    csv += `Frequência de Pico,${peakFreq.toFixed(4)},Hz\n`;
    csv += `Amplitude (RMS),${rms.toFixed(4)},m/s^2\n`;
    csv += `Potência Total,${totalPower.toExponential(4)},\n`;
    csv += `Proeminência do Pico,${peakProminence.toExponential(4)},\n`;
    csv += `FWHM,${fwhm.toFixed(4)},Hz\n`;
    csv += `Índice de Estabilidade (TSI),${tsi.toFixed(4)},\n`;
    csv += `Entropia Espectral,${spectralEntropy.toFixed(4)},\n`;
    csv += `Jerk (JR50),${jr50.toFixed(4)},m/s^3\n`;
    csv += `Índice Wavelet,${waveletIndex.toFixed(4)},\n`;
    csv += `Taxa de Amostragem,${sampleRate.toFixed(4)},Hz\n`;
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `metricas_tremor_${new Date().toISOString().slice(0,10)}.csv`;
    a.click();
    URL.revokeObjectURL(url);
}

function exportPdf() {
    if (!state.results) { alert("Nenhum resultado para exportar."); return; }
    if (typeof jspdf === 'undefined') { alert("Erro ao carregar a biblioteca de PDF."); return; }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'mm', 'a4');
    const { peakFreq, fwhm, tsi, spectralEntropy, times, rawSignal, detrendedSignal, freqs, psd, rms, jr50, totalPower, peakProminence, waveletIndex } = state.results;

    const margin = 15;
    const pageWidth = doc.internal.pageSize.getWidth();
    let currentY = 20;

    doc.setFont('helvetica', 'bold').setFontSize(20).text('Relatório de Análise de Tremor - TremorPSD', pageWidth / 2, currentY, { align: 'center' });
    currentY += 10;
    doc.setFont('helvetica', 'normal').setFontSize(10).text(new Date().toLocaleString('pt-BR'), pageWidth / 2, currentY, { align: 'center' });
    currentY += 15;

    doc.setFont('helvetica', 'bold').setFontSize(14).text('Métricas Principais', margin, currentY);
    currentY += 8;
    doc.setFont('helvetica', 'normal').setFontSize(11);
    const metricsCol1 = [
        `Freq. de Pico: ${peakFreq.toFixed(1)} Hz`,
        `Amplitude (RMS): ${rms.toFixed(2)}`,
        `Jerk (JR50): ${jr50.toFixed(1)}`,
        `FWHM: ${fwhm.toFixed(2)} Hz`,
    ];
    const metricsCol2 = [
        `Potência Total: ${totalPower.toExponential(1)}`,
        `Proeminência: ${peakProminence.toExponential(1)}`,
        `Índice Wavelet: ${waveletIndex.toFixed(2)}`,
        `Estabilidade (TSI): ${tsi.toFixed(2)}`
    ];
    metricsCol1.forEach((text, i) => doc.text(text, margin, currentY + (i * 7)));
    metricsCol2.forEach((text, i) => doc.text(text, pageWidth / 2 + 5, currentY + (i * 7)));
    currentY += (metricsCol1.length * 7) + 5;

    doc.setDrawColor(200).line(margin, currentY, pageWidth - margin, currentY);
    currentY += 10;

    const imgWidth = pageWidth - (margin * 2);
    const imgHeight = (imgWidth * timeChart.canvas.height) / timeChart.canvas.width;

    const generateChartImage = (chart, data, title) => {
        chart.data.datasets[0].data = data;
        chart.options.animation = false;
        chart.update();
        doc.setFont('helvetica', 'bold').setFontSize(12).text(title, margin, currentY);
        currentY += 6;
        doc.addImage(chart.toBase64Image('image/png', 1.0), 'PNG', margin, currentY, imgWidth, imgHeight);
        currentY += imgHeight + 8;
        if (currentY > doc.internal.pageSize.getHeight() - 30) { doc.addPage(); currentY = margin; }
    };
    
    timeChart.data.labels = times;
    generateChartImage(timeChart, rawSignal, '1. Sinal Bruto do Acelerômetro');
    generateChartImage(timeChart, detrendedSignal, '2. Sinal Processado (Sem Componente Contínua)');
    
    psdChart.data.labels = freqs;
    generateChartImage(psdChart, psd, '3. Densidade Espectral de Potência (PSD)');
    
    const originalMax = psdChart.options.scales.x.max;
    psdChart.options.scales.x.min = Math.max(0, peakFreq - 3);
    psdChart.options.scales.x.max = peakFreq + 3;
    generateChartImage(psdChart, psd, '4. Zoom no Pico Espectral');
    psdChart.options.scales.x.min = 0;
    psdChart.options.scales.x.max = originalMax;
    timeChart.options.animation = true;
    psdChart.options.animation = true;
    updateTimeSeriesChart();
    updatePsdChart();

    doc.addPage();
    currentY = margin;
    doc.setFont('helvetica', 'bold').setFontSize(14).text('Interpretação e Cálculo das Métricas', margin, currentY);
    currentY += 10;

    const addExplanation = (title, text) => {
        doc.setFont('helvetica', 'bold').setFontSize(10);
        doc.text(title, margin, currentY);
        currentY += 5;
        doc.setFont('helvetica', 'normal').setFontSize(9);
        const splitText = doc.splitTextToSize(text, pageWidth - (margin * 2));
        doc.text(splitText, margin, currentY);
        currentY += (splitText.length * 4) + 6;
        if (currentY > doc.internal.pageSize.getHeight() - 20) { doc.addPage(); currentY = margin; }
    };

    addExplanation('Amplitude (RMS - Root Mean Square)', 'Mede a intensidade ou amplitude efetiva do tremor no domínio do tempo. É calculado como a raiz quadrada da média dos quadrados dos valores do sinal de aceleração.');
    addExplanation('Jerk (JR50)', 'O "jerk" é a derivada da aceleração, medindo a suavidade do movimento. JR50 é a mediana (percentil 50) dos valores de jerk, indicando a "brusquidão" típica do movimento. Valores altos sugerem movimentos irregulares e súbitos.');
    addExplanation('Potência Total e Proeminência do Pico', 'A Potência Total é a energia total do tremor, calculada somando-se todos os valores da PSD. A Proeminência mede o quão um pico se destaca do "chão" do espectro, indicando a clareza do sinal rítmico em relação ao ruído.');
    addExplanation('Índice Wavelet', 'Mede a consistência da energia do tremor em sua frequência de pico ao longo do tempo. Um valor próximo de 1 indica que o tremor é estável e contínuo, enquanto valores baixos sugerem um tremor intermitente ou com frequência variável.');
    
    const disclaimerText = "Atenção: Este relatório é gerado automaticamente e não substitui um diagnóstico médico. Os resultados devem ser interpretados por um profissional de saúde qualificado.";
    const splitDisclaimer = doc.splitTextToSize(disclaimerText, pageWidth - (margin * 2));
    doc.setFont('helvetica', 'italic').setFontSize(8).text(splitDisclaimer, margin, doc.internal.pageSize.getHeight() - 20);

    doc.save(`Relatorio-TremorPSD-${new Date().toISOString().slice(0,10)}.pdf`);
}

function resetApp() {
    state.data = [];
    state.results = null;
    state.collecting = false;
    
    document.getElementById('resultsSection').classList.add('hidden');
    document.getElementById('footerActions').classList.add('hidden');
    
    timeChart.data.labels = [];
    timeChart.data.datasets[0].data = [];
    timeChart.update('none');
    psdChart.data.labels = [];
    psdChart.data.datasets[0].data = [];
    psdChart.update('none');
    
    updateUI('ready');
    if ('vibrate' in navigator) navigator.vibrate(50);
}

</script>

</body>
</html>
