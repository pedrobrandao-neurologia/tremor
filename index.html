<!DOCTYPE html>
<html lang="pt-BR" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>TremorPSD - Análise Aprimorada</title>
    
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Chart.js via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- jsPDF via CDN for PDF Export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- Custom Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* Estilos base e customizações */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        /* Animação de pulso para o ícone */
        @keyframes pulse-glow {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 20px 10px rgba(59, 130, 246, 0);
            }
        }
        .pulse-glow-animation {
            animation: pulse-glow 2s infinite cubic-bezier(0.4, 0, 0.6, 1);
        }
    </style>
</head>
<body class="bg-gray-900 text-white antialiased min-h-screen">

    <!-- Onboarding Screen -->
    <div id="onboarding" class="fixed inset-0 bg-gradient-to-br from-indigo-600 to-purple-700 flex flex-col justify-center items-center p-6 z-50 transition-opacity duration-500">
        <div class="bg-white/20 backdrop-blur-lg p-6 rounded-3xl mb-8">
            <svg class="w-16 h-16 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
        </div>
        <h1 class="text-4xl font-bold mb-4 text-center">Bem-vindo ao TremorPSD</h1>
        <p class="text-lg text-white/80 text-center max-w-sm mb-10">Analise tremores de forma precisa usando os sensores do seu dispositivo. Posicione o aparelho na mão ou membro a ser avaliado e siga as instruções.</p>
        <button onclick="startOnboarding()" class="bg-white text-indigo-600 font-semibold text-lg py-4 px-12 rounded-full shadow-2xl transform hover:scale-105 active:scale-95 transition-transform duration-200">
            Começar Análise
        </button>
    </div>

    <!-- Main App Container -->
    <div id="app" class="opacity-0 transition-opacity duration-500">
        <header class="bg-gray-900/70 backdrop-blur-lg sticky top-0 z-40 border-b border-gray-700/50 p-4">
            <div class="max-w-4xl mx-auto">
                <h1 class="text-xl font-bold">TremorPSD</h1>
                <p class="text-sm text-gray-400">Análise de Tremor por Densidade Espectral de Potência</p>
            </div>
        </header>

        <main class="p-4 max-w-4xl mx-auto pb-24">
            <!-- Status & Control Section -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <!-- Status Card -->
                <div id="statusCard" class="bg-gray-800 rounded-2xl p-6 border-t-4 border-blue-500 transition-all duration-300">
                    <div class="flex items-center space-x-4">
                        <div id="statusIconContainer" class="w-16 h-16 bg-gray-700 rounded-full flex items-center justify-center flex-shrink-0">
                            <div id="spinner" class="w-8 h-8 border-4 border-gray-600 border-t-blue-500 rounded-full animate-spin"></div>
                            <svg id="iconReady" class="hidden w-10 h-10 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                        </div>
                        <div>
                            <p id="statusText" class="text-lg font-semibold">Preparando sensores...</p>
                            <p id="statusDetail" class="text-sm text-gray-400">Aguarde a inicialização</p>
                        </div>
                    </div>
                </div>

                <!-- Control Panel -->
                <div class="bg-gray-800 rounded-2xl p-6">
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <label for="duration" class="text-sm text-gray-400 block mb-1">Duração (s)</label>
                            <input type="number" id="duration" value="20" min="5" max="60" class="w-full bg-gray-700 text-white rounded-lg p-2 border border-gray-600 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                        </div>
                        <div>
                            <label for="axis" class="text-sm text-gray-400 block mb-1">Eixo do Sinal</label>
                            <select id="axis" class="w-full bg-gray-700 text-white rounded-lg p-2 border border-gray-600 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                                <option value="mag">Magnitude</option>
                                <option value="x">Eixo X</option>
                                <option value="y">Eixo Y</option>
                                <option value="z">Eixo Z</option>
                            </select>
                        </div>
                    </div>
                    <button id="actionBtn" onclick="handleAction()" disabled class="w-full bg-blue-600 text-white font-semibold py-3 rounded-lg transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed hover:bg-blue-700 active:bg-blue-800 relative overflow-hidden">
                        <span id="actionText">Aguardando Sensores</span>
                        <div id="progressBar" class="absolute bottom-0 left-0 h-1 bg-white/30" style="width: 0%;"></div>
                    </button>
                </div>
            </div>

            <!-- Results Section (Initially Hidden) -->
            <div id="resultsSection" class="hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold">Resultados da Análise</h2>
                     <button onclick="showInfoModal()" class="text-blue-400 hover:text-blue-300 flex items-center space-x-1">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        <span>O que isso significa?</span>
                    </button>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <!-- Metrics Grid -->
                    <div class="bg-gray-800 rounded-2xl p-6">
                        <h3 class="font-semibold mb-4 text-lg">Métricas Principais</h3>
                        <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                            <div class="bg-gray-700/50 p-3 rounded-lg text-center">
                                <p class="text-xs text-gray-400">Freq. de Pico</p>
                                <p id="metricFreq" class="text-xl font-bold text-blue-400">— Hz</p>
                            </div>
                            <div class="bg-gray-700/50 p-3 rounded-lg text-center">
                                <p class="text-xs text-gray-400">FWHM</p>
                                <p id="metricFwhm" class="text-xl font-bold text-yellow-400">— Hz</p>
                            </div>
                            <div class="bg-gray-700/50 p-3 rounded-lg text-center">
                                <p class="text-xs text-gray-400">Pico/Total (PTR)</p>
                                <p id="metricPtr" class="text-xl font-bold text-green-400">—</p>
                            </div>
                            <div class="bg-gray-700/50 p-3 rounded-lg text-center">
                                <p class="text-xs text-gray-400">TSI</p>
                                <p id="metricTsi" class="text-xl font-bold text-purple-400">—</p>
                            </div>
                            <div class="bg-gray-700/50 p-3 rounded-lg text-center">
                                <p class="text-xs text-gray-400">Centroide Esp.</p>
                                <p id="metricCentroid" class="text-xl font-bold text-orange-400">— Hz</p>
                            </div>
                            <div class="bg-gray-700/50 p-3 rounded-lg text-center">
                                <p class="text-xs text-gray-400">Entropia Esp.</p>
                                <p id="metricEntropy" class="text-xl font-bold text-pink-400">—</p>
                            </div>
                        </div>
                    </div>
                    <!-- Classification -->
                    <div class="bg-gray-800 rounded-2xl p-6">
                        <h3 class="font-semibold mb-4 text-lg">Classificação Sugerida</h3>
                        <div class="space-y-3" id="classificationContainer">
                            <!-- Items inserted by JS -->
                        </div>
                    </div>
                </div>
                
                <!-- Charts Section -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-gray-800 rounded-2xl p-4 h-64">
                        <h3 class="font-semibold mb-2 text-center text-gray-300">Sinal no Tempo</h3>
                        <canvas id="chartTime"></canvas>
                    </div>
                    <div class="bg-gray-800 rounded-2xl p-4 h-64">
                        <h3 class="font-semibold mb-2 text-center text-gray-300">Densidade Espectral de Potência (PSD)</h3>
                        <canvas id="chartPSD"></canvas>
                    </div>
                </div>
            </div>
        </main>
        
        <!-- Footer Actions -->
        <footer id="footerActions" class="hidden fixed bottom-0 left-0 right-0 bg-gray-800/80 backdrop-blur-lg border-t border-gray-700 p-2 md:p-4">
            <div class="max-w-4xl mx-auto flex gap-2 md:gap-4">
                <button onclick="exportPdf()" class="w-full bg-red-600 text-white font-semibold py-3 rounded-lg hover:bg-red-700 transition-colors text-sm md:text-base">Exportar PDF</button>
                <button onclick="exportCsv()" class="w-full bg-gray-600 text-white font-semibold py-3 rounded-lg hover:bg-gray-700 transition-colors text-sm md:text-base">Exportar CSV</button>
                <button onclick="resetApp()" class="w-full bg-blue-600 text-white font-semibold py-3 rounded-lg hover:bg-blue-700 transition-colors text-sm md:text-base">Nova Análise</button>
            </div>
        </footer>
    </div>

    <!-- Info Modal -->
    <div id="infoModal" class="fixed inset-0 bg-black/70 flex items-center justify-center p-4 z-50 hidden" onclick="hideInfoModal(event)">
        <div class="bg-gray-800 rounded-2xl max-w-2xl w-full max-h-[80vh] overflow-y-auto p-6" id="infoModalContent">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Entendendo os Resultados</h2>
                <button onclick="hideInfoModal()" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div class="prose prose-invert prose-sm md:prose-base text-gray-300 space-y-4">
                <p>Esta análise transforma o sinal do acelerômetro (tremor) em um gráfico de **Densidade Espectral de Potência (PSD)**, que mostra quais frequências são mais intensas.</p>
                
                <div>
                    <h4 class="font-semibold text-white">Frequência de Pico (Hz)</h4>
                    <p>A frequência onde o tremor é mais forte. É o principal indicador para classificar o tipo de tremor.</p>
                </div>
                <div>
                    <h4 class="font-semibold text-white">FWHM (Hz)</h4>
                    <p>"Largura à Meia Altura". Mede a regularidade do tremor. Um valor baixo (pico fino) significa um tremor rítmico. Um valor alto (pico largo) sugere irregularidade.</p>
                </div>
                <div>
                    <h4 class="font-semibold text-white">Razão Pico/Total (PTR)</h4>
                    <p>Mede a concentração de potência do tremor. Um valor alto indica que quase toda a "energia" do tremor está na frequência de pico, sugerindo um tremor "puro".</p>
                </div>
                <div>
                    <h4 class="font-semibold text-white">Índice de Estabilidade (TSI)</h4>
                    <p>Calculado como FWHM / Freq. de Pico. É uma medida normalizada da estabilidade do pico. Valores baixos (ex: < 0.2) indicam um tremor muito estável.</p>
                </div>
                <div>
                    <h4 class="font-semibold text-white">Centroide Espectral (Hz)</h4>
                    <p>O "centro de massa" da potência do espectro. Se o centroide estiver próximo da Frequência de Pico, indica um tremor com pouca interferência de outras frequências.</p>
                </div>
                <div>
                    <h4 class="font-semibold text-white">Entropia Espectral</h4>
                    <p>Mede a complexidade ou "desordem" do sinal. Um tremor rítmico e puro tem baixa entropia. Um sinal ruidoso ou com múltiplos picos de tremor tem alta entropia.</p>
                </div>
                <div>
                    <h4 class="font-semibold text-white">Classificação Sugerida</h4>
                    <p>Com base nas características encontradas, o sistema oferece uma sugestão. <strong>Isto não é um diagnóstico</strong> e deve ser interpretado por um profissional de saúde qualificado.</p>
                </div>
                 <p class="text-xs text-gray-500 pt-4 border-t border-gray-700">A análise é feita usando o Método de Welch para calcular a PSD, uma técnica robusta para análise de sinais biológicos.</p>
            </div>
        </div>
    </div>


<script>
// --- GLOBAL STATE & CONFIG ---
const state = {
    sensorReady: false,
    collecting: false,
    data: [],
    results: null,
    sampleRate: 0,
    eventCount: 0,
    startTime: null,
};

let timeChart, psdChart;

const CLASSIFICATION_TYPES = {
    OT: { label: 'Ortostático', color: '#FBBF24' }, // amber-400
    ET: { label: 'Essencial', color: '#34D399' }, // emerald-400
    DT: { label: 'Distônico', color: '#F87171' }, // red-400
    MY: { label: 'Mioclonia', color: '#60A5FA' }, // blue-400
};


// --- INITIALIZATION & PERMISSIONS ---
window.addEventListener('load', () => {
    const isSecureContext = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
    if (!isSecureContext) {
        // On an insecure context, do nothing on load.
        // Let the user click the "Start Analysis" button, which will then display the detailed error.
        return;
    }

    // Attempt to initialize app directly if the context is secure and user has already granted permission.
    requestSensorPermission().then(granted => {
        if (granted) {
            hideOnboarding();
        }
    });
});

function startOnboarding() {
    const isSecureContext = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
    if (!isSecureContext) {
        const p = document.querySelector('#onboarding p');
        const btn = document.querySelector('#onboarding button');
        p.innerHTML = '<strong>Erro de Segurança:</strong> O acesso aos sensores requer um ambiente seguro (HTTPS ou localhost). Este arquivo não pode ser aberto diretamente no navegador.';
        btn.textContent = 'Entendido';
        btn.onclick = null; 
        btn.disabled = true;
        btn.classList.add('opacity-50', 'cursor-not-allowed');
        return;
    }

    requestSensorPermission().then(granted => {
        if (granted) {
            hideOnboarding();
        } else {
            // This handles cases where the user denies permission on a secure context
            document.querySelector('#onboarding p').textContent = 'A permissão para acessar os sensores foi negada. Por favor, habilite-a nas configurações do seu navegador e atualize a página.';
            document.querySelector('#onboarding button').textContent = 'Tentar Novamente';
            document.querySelector('#onboarding button').onclick = () => location.reload();
        }
    });
}

function hideOnboarding() {
    const onboardingEl = document.getElementById('onboarding');
    const appEl = document.getElementById('app');
    onboardingEl.classList.add('opacity-0', 'pointer-events-none');
    appEl.classList.remove('opacity-0');
    setTimeout(initializeApp, 500);
}

async function requestSensorPermission() {
    // Security check is now handled by the callers.
    try {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            const permission = await DeviceMotionEvent.requestPermission();
            return permission === 'granted';
        }
        // For Android/other devices that don't require explicit permission
        return true;
    } catch (error) {
        console.error('Error requesting sensor permission:', error);
        return false;
    }
}

function initializeApp() {
    setupMotionListener();
    initCharts();
    setTimeout(checkSensorStatus, 1500);
}

function checkSensorStatus() {
    if (state.eventCount > 0) {
        state.sensorReady = true;
        updateUI('ready');
    } else {
        updateUI('error', {
            text: 'Sensor não detectado',
            detail: 'Mova o dispositivo para ativá-lo.'
        });
    }
}

// --- UI MANAGEMENT ---
function updateUI(status, details = {}) {
    const statusCard = document.getElementById('statusCard');
    const statusIconContainer = document.getElementById('statusIconContainer');
    const spinner = document.getElementById('spinner');
    const iconReady = document.getElementById('iconReady');
    const statusText = document.getElementById('statusText');
    const statusDetail = document.getElementById('statusDetail');
    const actionBtn = document.getElementById('actionBtn');
    const actionText = document.getElementById('actionText');
    
    // Reset classes
    statusCard.className = 'bg-gray-800 rounded-2xl p-6 border-t-4 transition-all duration-300';
    statusIconContainer.classList.remove('pulse-glow-animation');
    spinner.classList.add('hidden');
    iconReady.classList.add('hidden');
    actionBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'bg-green-500');
    actionBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');

    switch (status) {
        case 'initializing':
            statusText.textContent = 'Preparando sensores...';
            statusDetail.textContent = 'Aguarde a inicialização';
            statusCard.classList.add('border-blue-500');
            spinner.classList.remove('hidden');
            actionBtn.disabled = true;
            actionText.textContent = 'Aguardando Sensores';
            break;
        case 'ready':
            statusText.textContent = 'Pronto para análise';
            statusDetail.textContent = `Taxa de amostra: ${state.sampleRate.toFixed(0)} Hz`;
            statusCard.classList.add('border-green-500');
            statusIconContainer.classList.add('pulse-glow-animation');
            iconReady.classList.remove('hidden');
            actionBtn.disabled = false;
            actionText.textContent = 'Iniciar Coleta';
            break;
        case 'collecting':
            statusText.textContent = 'Coletando dados...';
            statusCard.classList.add('border-yellow-500');
            spinner.classList.remove('hidden');
            actionBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
            actionBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
            actionText.textContent = 'Parar Coleta';
            break;
        case 'analyzing':
            statusText.textContent = 'Analisando...';
            statusDetail.textContent = `${state.data.length} amostras coletadas.`;
            statusCard.classList.add('border-purple-500');
            spinner.classList.remove('hidden');
            actionBtn.disabled = true;
            actionText.textContent = 'Processando...';
            break;
        case 'done':
            statusText.textContent = 'Análise Concluída';
            statusDetail.textContent = `Pico em ${state.results.peakFreq.toFixed(1)} Hz`;
            statusCard.classList.add('border-green-500');
            iconReady.classList.remove('hidden');
            actionBtn.disabled = true;
            actionText.textContent = 'Análise Completa';
            actionBtn.classList.add('bg-green-500');
            break;
        case 'error':
            statusText.textContent = details.text || 'Erro';
            statusDetail.textContent = details.detail || 'Tente novamente.';
            statusCard.classList.add('border-red-500');
            // Add error icon here if needed
            actionBtn.disabled = true;
            actionText.textContent = 'Erro no Sensor';
            break;
    }
}

function showInfoModal() {
    document.getElementById('infoModal').classList.remove('hidden');
}

function hideInfoModal(event) {
    if (event && event.target.id !== 'infoModal') return;
    document.getElementById('infoModal').classList.add('hidden');
}


// --- SENSOR & DATA COLLECTION ---
function setupMotionListener() {
    let lastTime = performance.now();
    
    const handleMotion = (event) => {
        state.eventCount++;
        const now = performance.now();
        const dt = (now - lastTime) / 1000;
        if (dt > 0) {
            const currentRate = 1 / dt;
            // Weighted moving average for sample rate
            state.sampleRate = state.sampleRate * 0.95 + currentRate * 0.05;
        }
        lastTime = now;

        if (state.collecting) {
            const acc = event.accelerationIncludingGravity;
            if (!acc) return;

            const t = (now - state.startTime) / 1000;
            const axis = document.getElementById('axis').value;
            let value;
            switch(axis) {
                case 'x': value = acc.x; break;
                case 'y': value = acc.y; break;
                case 'z': value = acc.z; break;
                default: value = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
            }
            state.data.push({ t, v: value });
            updateProgress();
        }
    };

    window.addEventListener('devicemotion', handleMotion, true);
}

function handleAction() {
    state.collecting ? stopCollection() : startCollection();
}

function startCollection() {
    state.data = [];
    state.collecting = true;
    state.startTime = performance.now();
    
    document.getElementById('resultsSection').classList.add('hidden');
    document.getElementById('footerActions').classList.add('hidden');
    
    updateUI('collecting');

    const duration = parseInt(document.getElementById('duration').value) * 1000;
    setTimeout(() => {
        if (state.collecting) stopCollection();
    }, duration);
}

function stopCollection() {
    state.collecting = false;
    if ('vibrate' in navigator) navigator.vibrate(100);
    
    document.getElementById('progressBar').style.width = '0%';
    updateUI('analyzing');
    
    setTimeout(analyzeData, 500); // Allow UI to update
}

function updateProgress() {
    const duration = parseInt(document.getElementById('duration').value);
    const elapsed = (performance.now() - state.startTime) / 1000;
    const progress = Math.min(100, (elapsed / duration) * 100);
    
    document.getElementById('progressBar').style.width = `${progress}%`;
    document.getElementById('statusDetail').textContent = `Restam ${(duration - elapsed).toFixed(0)}s | ${state.data.length} amostras`;
}


// --- SIGNAL PROCESSING & ANALYSIS ---

// Radix-2 FFT implementation
function fft(real, imag) {
    const n = real.length;
    if (n === 0) return;

    // Bit-reversal permutation
    for (let i = 1, j = 0; i < n; i++) {
        let bit = n >> 1;
        for (; (j & bit) !== 0; bit >>= 1)
            j ^= bit;
        j ^= bit;
        if (i < j) {
            [real[i], real[j]] = [real[j], real[i]];
            [imag[i], imag[j]] = [imag[j], imag[i]];
        }
    }

    // Cooley-Tukey FFT
    for (let len = 2; len <= n; len <<= 1) {
        const halfLen = len >> 1;
        const angle = -2 * Math.PI / len;
        const w_real = Math.cos(angle);
        const w_imag = Math.sin(angle);
        for (let i = 0; i < n; i += len) {
            let t_real = 1;
            let t_imag = 0;
            for (let j = 0; j < halfLen; j++) {
                const u_real = real[i + j];
                const u_imag = imag[i + j];
                const v_real = real[i + j + halfLen] * t_real - imag[i + j + halfLen] * t_imag;
                const v_imag = real[i + j + halfLen] * t_imag + imag[i + j + halfLen] * t_real;
                real[i + j] = u_real + v_real;
                imag[i + j] = u_imag + v_imag;
                real[i + j + halfLen] = u_real - v_real;
                imag[i + j + halfLen] = u_imag - v_imag;
                [t_real, t_imag] = [t_real * w_real - t_imag * w_imag, t_real * w_imag + t_imag * w_real];
            }
        }
    }
}


// Welch's method for Power Spectral Density
function welch(signal, fs, nperseg) {
    const n = signal.length;
    nperseg = Math.min(nperseg, n);
    const noverlap = Math.floor(nperseg / 2);
    const step = nperseg - noverlap;
    
    // Hann window
    const window = new Float64Array(nperseg);
    for (let i = 0; i < nperseg; i++) {
        window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (nperseg - 1)));
    }
    const scale = 1.0 / (fs * (window.reduce((a, b) => a + b*b, 0) / nperseg));

    let psd = new Float64Array(Math.floor(nperseg / 2) + 1).fill(0);
    let numSegments = 0;

    for (let i = 0; i + nperseg <= n; i += step) {
        const segment = signal.slice(i, i + nperseg);
        
        let real = new Float64Array(nperseg);
        for (let j = 0; j < nperseg; j++) {
            real[j] = segment[j] * window[j];
        }
        let imag = new Float64Array(nperseg).fill(0);

        fft(real, imag);
        
        for (let j = 0; j < psd.length; j++) {
            const specVal = real[j]**2 + imag[j]**2;
            psd[j] += (j > 0 && j < psd.length - 1) ? 2 * specVal : specVal;
        }
        numSegments++;
    }

    if (numSegments > 0) {
        psd = psd.map(v => v * scale / numSegments);
    }

    const freqs = new Float64Array(psd.length);
    for (let i = 0; i < psd.length; i++) {
        freqs[i] = i * fs / nperseg;
    }
    
    return { freqs, psd };
}


function analyzeData() {
    if (state.data.length < 50) {
        updateUI('error', { text: 'Dados Insuficientes', detail: 'Colete por mais tempo.' });
        return;
    }

    const signal = state.data.map(d => d.v);
    const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
    const detrended = signal.map(v => v - mean);
    
    const fs = state.sampleRate;
    const nperseg = Math.pow(2, Math.floor(Math.log2(fs * 2))); // ~2 seconds window

    const { freqs, psd } = welch(detrended, fs, nperseg);

    // Find peak in the 2-20 Hz range
    let peakPower = 0;
    let peakIdx = -1;
    for (let i = 0; i < freqs.length; i++) {
        if (freqs[i] >= 2 && freqs[i] <= 20) {
            if (psd[i] > peakPower) {
                peakPower = psd[i];
                peakIdx = i;
            }
        }
    }
    
    if (peakIdx === -1) {
         updateUI('error', { text: 'Pico não detectado', detail: 'O sinal de tremor pode ser muito fraco.' });
        return;
    }
    const peakFreq = freqs[peakIdx];

    // Calculate FWHM (Full Width at Half Maximum)
    const halfMax = peakPower / 2;
    let leftIdx = peakIdx;
    while (leftIdx > 0 && psd[leftIdx] > halfMax) leftIdx--;
    let rightIdx = peakIdx;
    while (rightIdx < freqs.length - 1 && psd[rightIdx] > halfMax) rightIdx++;
    const fwhm = freqs[rightIdx] - freqs[leftIdx];

    // --- NEW METRICS CALCULATION ---
    const totalPower = psd.reduce((a, b) => a + b, 1e-12); // Add epsilon to avoid division by zero
    const ptr = peakPower / totalPower;
    const tsi = peakFreq > 0 ? fwhm / peakFreq : 0;
    const spectralCentroid = psd.reduce((sum, p, i) => sum + p * freqs[i], 0) / totalPower;
    
    const normalizedPsd = psd.map(p => p / totalPower);
    const spectralEntropy = -normalizedPsd.reduce((sum, p) => sum + (p > 0 ? p * Math.log2(p) : 0), 0);

    state.results = {
        times: state.data.map(d => d.t),
        signal: detrended,
        freqs,
        psd,
        peakFreq,
        peakPower,
        fwhm,
        ptr,
        tsi,
        spectralCentroid,
        spectralEntropy,
        sampleRate: fs
    };

    displayResults();
    classifyTremor();

    updateUI('done');
    document.getElementById('resultsSection').classList.remove('hidden');
    document.getElementById('footerActions').classList.remove('hidden');
}


// --- RESULTS DISPLAY & CHARTS ---
function displayResults() {
    const { peakFreq, fwhm, ptr, tsi, spectralCentroid, spectralEntropy } = state.results;

    document.getElementById('metricFreq').textContent = `${peakFreq.toFixed(1)} Hz`;
    document.getElementById('metricFwhm').textContent = `${fwhm.toFixed(2)} Hz`;
    document.getElementById('metricPtr').textContent = `${ptr.toFixed(2)}`;
    document.getElementById('metricTsi').textContent = `${tsi.toFixed(2)}`;
    document.getElementById('metricCentroid').textContent = `${spectralCentroid.toFixed(1)} Hz`;
    document.getElementById('metricEntropy').textContent = `${spectralEntropy.toFixed(2)}`;

    updateTimeSeriesChart();
    updatePsdChart();
}

function classifyTremor() {
    const { peakFreq, tsi, ptr } = state.results;
    let scores = { OT: 0, ET: 0, DT: 0, MY: 0 };
    
    const stabilityFactor = Math.max(0, 1 - tsi * 2); // Higher for stable tremors (low TSI)
    const purityFactor = ptr; // Higher for "pure" tremors (high PTR)

    // Essential Tremor (4-12 Hz, very stable and pure)
    if (peakFreq >= 4 && peakFreq <= 12) {
        scores.ET = (1 - Math.abs(peakFreq - 8) / 4) * stabilityFactor * purityFactor;
    }
    // Orthostatic Tremor (13-18 Hz, extremely stable and pure)
    if (peakFreq >= 13 && peakFreq <= 18) {
        scores.OT = (1 - Math.abs(peakFreq - 15.5) / 2.5) * Math.pow(stabilityFactor, 2) * Math.pow(purityFactor, 2);
    }
     // Dystonic Tremor (4-9 Hz, less stable/pure)
    if (peakFreq >= 4 && peakFreq <= 9) {
        scores.DT = (1 - stabilityFactor) * (1 - purityFactor) * 0.5;
    }
    // Myoclonus (very unstable/impure)
    if ((1-stabilityFactor) > 0.5 && (1-purityFactor) > 0.7) {
        scores.MY = (1 - stabilityFactor) * 0.4;
    }

    const total = Object.values(scores).reduce((a, b) => a + b, 1e-9);
    const container = document.getElementById('classificationContainer');
    container.innerHTML = ''; // Clear previous results

    for (const type in scores) {
        const pct = total > 0 ? (scores[type] / total) * 100 : 0;
        const { label, color } = CLASSIFICATION_TYPES[type];
        
        const item = document.createElement('div');
        item.innerHTML = `
            <div class="flex justify-between items-center mb-1">
                <span class="text-sm">${label}</span>
                <span class="text-sm font-semibold">${pct.toFixed(0)}%</span>
            </div>
            <div class="w-full bg-gray-700 rounded-full h-2.5">
                <div class="bg-blue-500 h-2.5 rounded-full transition-all duration-1000 ease-out" style="width: ${pct}%; background-color: ${color};"></div>
            </div>
        `;
        container.appendChild(item);
    }
}

function initCharts() {
    const commonOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: {
            x: { 
                ticks: { color: '#9CA3AF' }, 
                grid: { color: 'rgba(255,255,255,0.1)' } 
            },
            y: { 
                ticks: { color: '#9CA3AF' }, 
                grid: { color: 'rgba(255,255,255,0.1)' }
            }
        }
    };

    timeChart = new Chart(document.getElementById('chartTime'), {
        type: 'line',
        data: { labels: [], datasets: [{ data: [], borderColor: '#60A5FA', borderWidth: 1.5, pointRadius: 0, tension: 0.1 }] },
        options: { ...commonOptions, scales: { ...commonOptions.scales, x: { ...commonOptions.scales.x, title: { display: true, text: 'Tempo (s)', color: '#9CA3AF' } } } }
    });
    
    psdChart = new Chart(document.getElementById('chartPSD'), {
        type: 'line',
        data: { labels: [], datasets: [{ data: [], borderColor: '#34D399', borderWidth: 2, pointRadius: 0, fill: { target: 'origin', above: 'rgba(52, 211, 153, 0.2)' } }] },
        options: { ...commonOptions, scales: { ...commonOptions.scales, x: { ...commonOptions.scales.x, title: { display: true, text: 'Frequência (Hz)', color: '#9CA3AF' }, max: 25 }, y: { ...commonOptions.scales.y, title: { display: true, text: 'Potência', color: '#9CA3AF' } } } }
    });
}

function updateTimeSeriesChart() {
    const { times, signal } = state.results;
    timeChart.data.labels = times;
    timeChart.data.datasets[0].data = signal;
    timeChart.update('none');
}

function updatePsdChart() {
    const { freqs, psd } = state.results;
    psdChart.data.labels = freqs;
    psdChart.data.datasets[0].data = psd;
    psdChart.update('none');
}


// --- UTILITIES & APP LIFECYCLE ---
function exportCsv() {
    if (!state.data || state.data.length === 0) return;
    
    let csv = 'Time(s),Acceleration(m/s^2)\n';
    state.data.forEach(row => {
        csv += `${row.t.toFixed(6)},${row.v.toFixed(6)}\n`;
    });
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `tremor_analysis_${new Date().toISOString().slice(0,10)}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    if ('vibrate' in navigator) navigator.vibrate(50);
}

function exportPdf() {
    if (!state.results) {
        alert("Nenhum resultado para exportar. Por favor, realize uma análise primeiro.");
        return;
    }
    if (typeof jspdf === 'undefined') {
        alert("Erro ao carregar a biblioteca de PDF. Tente recarregar a página.");
        return;
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'mm', 'a4'); // portrait, millimeters, a4
    const { peakFreq, fwhm, ptr, tsi, spectralCentroid, spectralEntropy } = state.results;

    const margin = 15;
    const pageWidth = doc.internal.pageSize.getWidth();
    let currentY = 20;

    // Title
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(20);
    doc.text('Relatório de Análise de Tremor - TremorPSD', pageWidth / 2, currentY, { align: 'center' });
    currentY += 10;

    // Date
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(10);
    doc.text(new Date().toLocaleString('pt-BR'), pageWidth / 2, currentY, { align: 'center' });
    currentY += 15;

    // Metrics Section
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(14);
    doc.text('Métricas Principais', margin, currentY);
    currentY += 8;

    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    
    const metricsCol1 = [
        `Frequência de Pico: ${peakFreq.toFixed(1)} Hz`,
        `FWHM: ${fwhm.toFixed(2)} Hz`,
        `Razão Pico/Total (PTR): ${ptr.toFixed(2)}`
    ];
    const metricsCol2 = [
        `Índice de Estabilidade (TSI): ${tsi.toFixed(2)}`,
        `Centroide Espectral: ${spectralCentroid.toFixed(1)} Hz`,
        `Entropia Espectral: ${spectralEntropy.toFixed(2)}`
    ];
    
    const col2X = pageWidth / 2 + 5;
    
    for (let i = 0; i < metricsCol1.length; i++) {
        doc.text(metricsCol1[i], margin, currentY + (i * 7));
        if (metricsCol2[i]) {
            doc.text(metricsCol2[i], col2X, currentY + (i * 7));
        }
    }
    currentY += (metricsCol1.length * 7) + 5;

    // Add a line separator
    doc.setDrawColor(200);
    doc.line(margin, currentY, pageWidth - margin, currentY);
    currentY += 10;

    // Charts Section
    const timeChartImg = timeChart.toBase64Image('image/png', 1.0);
    const psdChartImg = psdChart.toBase64Image('image/png', 1.0);
    const imgWidth = pageWidth - (margin * 2);
    
    const canvasWidth = timeChart.canvas.width;
    const canvasHeight = timeChart.canvas.height;
    const imgHeight = (imgWidth * canvasHeight) / canvasWidth;

    // Time Chart
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(14);
    doc.text('Gráfico do Sinal no Tempo', margin, currentY);
    currentY += 6;
    doc.addImage(timeChartImg, 'PNG', margin, currentY, imgWidth, imgHeight);
    currentY += imgHeight + 10;

    // PSD Chart
    doc.text('Gráfico de Densidade Espectral de Potência (PSD)', margin, currentY);
    currentY += 6;
    doc.addImage(psdChartImg, 'PNG', margin, currentY, imgWidth, imgHeight);
    currentY += imgHeight + 15;
    
    if (currentY > doc.internal.pageSize.getHeight() - 20) {
        doc.addPage();
        currentY = margin;
    }

    // Disclaimer
    doc.setFont('helvetica', 'italic');
    doc.setFontSize(8);
    const disclaimerText = "Atenção: Este relatório é gerado automaticamente e não substitui um diagnóstico médico. Os resultados devem ser interpretados por um profissional de saúde qualificado.";
    const splitDisclaimer = doc.splitTextToSize(disclaimerText, pageWidth - (margin * 2));
    doc.text(splitDisclaimer, margin, currentY);

    // Save PDF
    doc.save(`Relatorio-TremorPSD-${new Date().toISOString().slice(0,10)}.pdf`);
    if ('vibrate' in navigator) navigator.vibrate(50);
}

function resetApp() {
    state.data = [];
    state.results = null;
    state.collecting = false;
    
    document.getElementById('resultsSection').classList.add('hidden');
    document.getElementById('footerActions').classList.add('hidden');
    
    updateTimeSeriesChart();
    updatePsdChart();
    
    updateUI('ready');
    if ('vibrate' in navigator) navigator.vibrate(50);
}

</script>

</body>
</html>
