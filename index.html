<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>TremorAnalyzer - Sistema Clínico</title>
  <style>
    :root{
      --primary:#2563eb;--primary-light:#3b82f6;--success:#10b981;--warning:#f59e0b;--danger:#ef4444;
      --bg-primary:#ffffff;--bg-secondary:#f8fafc;--bg-card:#ffffff;--text-primary:#1f2937;--text-secondary:#6b7280;
      --border:#e5e7eb;--border-light:#f3f4f6;--shadow:0 1px 3px 0 rgb(0 0 0 / .1),0 1px 2px -1px rgb(0 0 0 / .1)
    }
    @media(prefers-color-scheme:dark){
      :root{--bg-primary:#0f172a;--bg-secondary:#1e293b;--bg-card:#1e293b;--text-primary:#f1f5f9;--text-secondary:#94a3b8;--border:#334155;--border-light:#475569}
    }
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family: -apple-system,BlinkMacSystemFont,'Segoe UI','Roboto',sans-serif;background:var(--bg-primary);color:var(--text-primary);line-height:1.6;min-height:100vh}
    .container{max-width:1200px;margin:0 auto;padding:20px}
    .header{background:var(--bg-card);border-bottom:1px solid var(--border);padding:24px 0;margin-bottom:32px;box-shadow:var(--shadow)}
    .header-content{max-width:1200px;margin:0 auto;padding:0 20px}
    .header h1{font-size:2rem;font-weight:700;color:var(--primary);margin-bottom:8px}
    .header p{color:var(--text-secondary);font-size:1.1rem}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:24px;margin-bottom:24px}
    @media(max-width:768px){.grid{grid-template-columns:1fr;gap:16px}}
    .card{background:var(--bg-card);border-radius:12px;padding:24px;border:1px solid var(--border)}
    .card-title{font-size:1.25rem;font-weight:600;margin-bottom:16px}
    .status-indicator{display:inline-flex;align-items:center;gap:8px;padding:8px 16px;border-radius:24px;font-size:.875rem;font-weight:500}
    .status-ready{background:#dcfce7;color:#16a34a;border:1px solid #bbf7d0}
    .status-warning{background:#fef3c7;color:#d97706;border:1px solid #fde68a}
    .status-error{background:#fee2e2;color:#dc2626;border:1px solid #fecaca}
    .form-group{margin-bottom:20px}
    .form-label{display:block;font-weight:500;margin-bottom:8px}
    .form-select,.form-input,textarea.form-input{width:100%;padding:12px 16px;border:1px solid var(--border);border-radius:8px;background:var(--bg-primary);color:var(--text-primary);font-size:1rem}
    .form-select:focus,.form-input:focus,textarea.form-input:focus{outline:none;border-color:var(--primary);box-shadow:0 0 0 3px rgb(37 99 235/0.1)}
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 24px;border:none;border-radius:8px;font-weight:500;font-size:1rem;cursor:pointer;transition:.2s;text-decoration:none}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .btn-primary{background:var(--primary);color:#fff}.btn-primary:hover:not(:disabled){background:var(--primary-light)}
    .btn-success{background:var(--success);color:#fff}
    .btn-warning{background:var(--warning);color:#fff}
    .btn-secondary{background:var(--bg-secondary);color:var(--text-primary);border:1px solid var(--border)}
    .btn-full{width:100%}
    .progress-bar{width:100%;height:8px;background:var(--border-light);border-radius:4px;overflow:hidden;margin:16px 0}
    .progress-fill{height:100%;background:var(--primary);transition:width .3s ease;border-radius:4px}
    .metrics-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:16px;margin:16px 0}
    .metric-card{background:var(--bg-secondary);padding:16px;border-radius:8px;text-align:center;border:1px solid var(--border-light)}
    .metric-value{font-size:1.5rem;font-weight:700;color:var(--primary);margin-bottom:4px}
    .metric-label{font-size:.875rem;color:var(--text-secondary)}
    .chart-container{width:100%;height:300px;background:var(--bg-secondary);border-radius:8px;margin:16px 0;position:relative;border:1px solid var(--border-light)}
    .classification-item{display:flex;align-items:center;margin-bottom:12px;gap:12px}
    .classification-label{min-width:100px;font-weight:500}
    .classification-bar{flex:1;height:24px;background:var(--border-light);border-radius:12px;overflow:hidden;position:relative}
    .classification-fill{height:100%;transition:width .5s ease;border-radius:12px}
    .classification-percentage{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:.75rem;font-weight:600;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.5)}
    .alert{padding:16px;border-radius:8px;margin-bottom:16px;border-left:4px solid}
    .alert-info{background:#eff6ff;border-color:var(--primary);color:#1e40af}
    .quality-indicators{display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:12px;margin:16px 0}
    .quality-item{text-align:center;padding:12px;background:var(--bg-secondary);border-radius:8px;border:1px solid var(--border-light)}
    .quality-value{font-size:1.25rem;font-weight:600;margin-bottom:4px}
    .quality-label{font-size:.75rem;color:var(--text-secondary)}
    .hidden{display:none!important}
    .loading{display:inline-block;width:16px;height:16px;border:2px solid transparent;border-top:2px solid currentColor;border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    canvas{width:100%;height:100%;border-radius:8px}
  </style>
</head>
<body>
  <div class="header">
    <div class="header-content">
      <h1>TremorAnalyzer</h1>
      <p>Sistema Clínico de Análise de Tremor por Acelerometria</p>
    </div>
  </div>

  <div class="container">
    <!-- Status -->
    <div class="card">
      <div class="card-title">Status do Sistema</div>
      <div id="systemStatus" class="status-indicator status-warning">
        <div class="loading"></div> Inicializando sensores...
      </div>
      <div id="qualityIndicators" class="quality-indicators hidden">
        <div class="quality-item">
          <div id="sampleRate" class="quality-value">--</div>
          <div class="quality-label">Taxa (Hz)</div>
        </div>
        <div class="quality-item">
          <div id="signalQuality" class="quality-value">--</div>
          <div class="quality-label">Qualidade</div>
        </div>
        <div class="quality-item">
          <div id="samples" class="quality-value">--</div>
          <div class="quality-label">Amostras</div>
        </div>
      </div>
    </div>

    <div class="grid">
      <!-- Coleta -->
      <div class="card">
        <div class="card-title">Configurações de Coleta</div>

        <div class="form-group">
          <label class="form-label">Protocolo Clínico</label>
          <select id="protocol" class="form-select">
            <option value="rest">Tremor de Repouso</option>
            <option value="postural">Tremor Postural</option>
            <option value="kinetic">Tremor Cinético</option>
            <option value="orthostatic">Tremor Ortostático</option>
          </select>
        </div>

        <div class="form-group">
          <label class="form-label">Componente do Sinal</label>
          <select id="axis" class="form-select">
            <option value="magnitude">Magnitude Total (√x²+y²+z²)</option>
            <option value="dominant">Componente Dominante</option>
            <option value="x">Eixo X (Medial-Lateral)</option>
            <option value="y">Eixo Y (Anterior-Posterior)</option>
            <option value="z">Eixo Z (Vertical)</option>
          </select>
        </div>

        <div class="form-group">
          <label class="form-label">Duração (segundos)</label>
          <input type="number" id="duration" class="form-input" value="30" min="20" max="120" step="10">
        </div>

        <div id="protocolInstructions" class="protocol-steps">
          <!-- preenchido via JS -->
        </div>

        <button id="recordBtn" class="btn btn-primary btn-full" disabled>
          <span id="recordText">Aguardando sensores...</span>
        </button>

        <div id="progressContainer" class="hidden">
          <div class="progress-bar"><div id="progressBar" class="progress-fill" style="width:0%"></div></div>
          <div id="progressText" style="text-align:center;font-size:.875rem;color:var(--text-secondary);"></div>
        </div>
      </div>

      <!-- Sessão -->
      <div class="card">
        <div class="card-title">Informações da Sessão</div>
        <div class="form-group">
          <label class="form-label">ID do Paciente (opcional)</label>
          <input type="text" id="patientId" class="form-input" placeholder="Ex: PAC001">
        </div>
        <div class="form-group">
          <label class="form-label">Observações Clínicas</label>
          <textarea id="clinicalNotes" class="form-input" rows="4" placeholder="Medicações, sintomas observados, contexto clínico..."></textarea>
        </div>
        <div class="alert alert-info">
          <strong>Protocolo Padronizado:</strong><br>
          Taxa mínima: 50 Hz | Duração: 20–60 s | Filtros: 3–20 Hz | Análise: Welch PSD
        </div>
      </div>
    </div>

    <!-- Resultados -->
    <div id="resultsSection" class="hidden">
      <div class="card">
        <div class="card-title">Métricas de Sinal</div>
        <div class="metrics-grid">
          <div class="metric-card"><div id="peakFreq" class="metric-value">--</div><div class="metric-label">Freq. Pico (Hz)</div></div>
          <div class="metric-card"><div id="peakPower" class="metric-value">--</div><div class="metric-label">Potência Pico</div></div>
          <div class="metric-card"><div id="fwhm" class="metric-value">--</div><div class="metric-label">FWHM (Hz)</div></div>
          <div class="metric-card"><div id="tremStab" class="metric-value">--</div><div class="metric-label">TSI</div></div>
          <div class="metric-card"><div id="specEntropy" class="metric-value">--</div><div class="metric-label">Entropia</div></div>
          <div class="metric-card"><div id="peakRatio" class="metric-value">--</div><div class="metric-label">PTR</div></div>
        </div>
      </div>

      <div class="grid">
        <div class="card">
          <div class="card-title">Sinal Temporal</div>
          <div class="chart-container"><canvas id="timeChart"></canvas></div>
        </div>
        <div class="card">
          <div class="card-title">Densidade Espectral de Potência</div>
          <div class="chart-container"><canvas id="psdChart"></canvas></div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">Classificação Diferencial</div>
        <div id="classificationResult"></div>

        <div class="classification-item">
          <div class="classification-label">Tremor Essencial</div>
          <div class="classification-bar">
            <div id="etFill" class="classification-fill" style="width:0%;background:#10b981;"></div>
            <div id="etPercent" class="classification-percentage">0%</div>
          </div>
        </div>
        <div class="classification-item">
          <div class="classification-label">Parkinson</div>
          <div class="classification-bar">
            <div id="pdFill" class="classification-fill" style="width:0%;background:#f59e0b;"></div>
            <div id="pdPercent" class="classification-percentage">0%</div>
          </div>
        </div>
        <div class="classification-item">
          <div class="classification-label">Distônico</div>
          <div class="classification-bar">
            <div id="dtFill" class="classification-fill" style="width:0%;background:#8b5cf6;"></div>
            <div id="dtPercent" class="classification-percentage">0%</div>
          </div>
        </div>
        <div class="classification-item">
          <div class="classification-label">Ortostático</div>
          <div class="classification-bar">
            <div id="otFill" class="classification-fill" style="width:0%;background:#ef4444;"></div>
            <div id="otPercent" class="classification-percentage">0%</div>
          </div>
        </div>
        <div class="classification-item">
          <div class="classification-label">Mioclonia</div>
          <div class="classification-bar">
            <div id="myFill" class="classification-fill" style="width:0%;background:#06b6d4;"></div>
            <div id="myPercent" class="classification-percentage">0%</div>
          </div>
        </div>

        <div id="diagnosticExplanation" class="alert alert-info" style="margin-top:16px;">
          Análise baseada em características espectrais e protocolos clínicos padronizados.
        </div>
      </div>

      <div class="card">
        <div class="card-title">Exportação de Dados</div>
        <p style="color:var(--text-secondary);margin-bottom:16px;">Exporte os dados para análise adicional ou documentação clínica.</p>
        <div class="export-buttons" style="display:flex;gap:12px;flex-wrap:wrap">
          <button id="exportCsv" class="btn btn-secondary">📊 Exportar CSV</button>
          <button id="exportJson" class="btn btn-secondary">📄 Exportar JSON</button>
          <button id="exportReport" class="btn btn-secondary">📋 Relatório Clínico</button>
          <button id="resetAnalysis" class="btn btn-warning">🔄 Nova Análise</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== ESTADO E CONFIG =====
    const State = {
      sensorReady:false, collecting:false, data:[], times:[],
      sampleRate:0, eventCount:0, results:null, startTime:null, lastEventTime:null
    };

    const Config = {
      targetSampleRate:100, minSampleRate:50,
      tremBandLow:3, tremBandHigh:20,
      welchSegmentLength:4, welchOverlap:0.5
    };

    const Protocols = {
      rest:{name:"Tremor de Repouso",instructions:[
        "Sente-se confortavelmente com antebraços apoiados",
        "Mantenha mãos relaxadas e imóveis no colo",
        "Evite conversar ou fazer movimentos voluntários",
        "Dispositivo no dorso da mão mais afetada"
      ]},
      postural:{name:"Tremor Postural",instructions:[
        "Estenda os braços à frente na horizontal",
        "Mãos em pronação, dedos estendidos",
        "Mantenha posição contra gravidade",
        "Dispositivo fixado no dorso da mão"
      ]},
      kinetic:{name:"Tremor Cinético",instructions:[
        "Execute movimento dedo-nariz-dedo continuamente",
        "Movimento suave e controlado",
        "Alterne entre ambas as mãos se necessário",
        "Dispositivo na mão executando o movimento"
      ]},
      orthostatic:{name:"Tremor Ortostático",instructions:[
        "Permaneça em pé com pés afastados",
        "Braços relaxados ao lado do corpo",
        "Evite apoiar-se em superfícies",
        "Dispositivo fixado na coxa ou tornozelo"
      ]}
    };

    // ===== INICIALIZAÇÃO =====
    document.addEventListener('DOMContentLoaded', () => {
      initializeApp();
      setupEventListeners();
      updateProtocolInstructions();
    });

    async function initializeApp(){
      const statusEl = document.getElementById('systemStatus');
      try{
        if(!isSecureContext()) throw new Error('Contexto inseguro: use HTTPS ou localhost.');
        if(!window.DeviceMotionEvent) throw new Error('Sensores de movimento não suportados.');

        // iOS exige gesto do usuário
        if(typeof DeviceMotionEvent.requestPermission === 'function'){
          statusEl.className = 'status-indicator status-warning';
          statusEl.innerHTML = `<button class="btn btn-primary" id="askPerm">Ativar Sensores</button>`;
          document.getElementById('askPerm').addEventListener('click', requestSensorPermission, {once:true});
          return;
        }
        await initializeSensors();
      }catch(err){
        statusEl.className = 'status-indicator status-error';
        statusEl.textContent = `❌ ${err.message}`;
      }
    }

    async function requestSensorPermission(){
      const statusEl = document.getElementById('systemStatus');
      try{
        const perm = await DeviceMotionEvent.requestPermission();
        if(perm !== 'granted') throw new Error('Permissão negada pelo usuário.');
        await initializeSensors();
      }catch(err){
        statusEl.className = 'status-indicator status-error';
        statusEl.textContent = `❌ ${err.message}`;
      }
    }

    async function initializeSensors(){
      const statusEl = document.getElementById('systemStatus');
      statusEl.className = 'status-indicator status-warning';
      statusEl.innerHTML = '<div class="loading"></div> Testando sensores...';

      window.addEventListener('devicemotion', handleMotionEvent, {passive:true});

      setTimeout(() => {
        if(State.eventCount > 10 && State.sampleRate > Config.minSampleRate){
          State.sensorReady = true;
          statusEl.className = 'status-indicator status-ready';
          statusEl.textContent = '✅ Sensores prontos';
          document.getElementById('recordBtn').disabled = false;
          document.getElementById('recordText').textContent = 'Iniciar Coleta';
          document.getElementById('qualityIndicators').classList.remove('hidden');
          setInterval(updateQualityIndicators, 1000);
        }else{
          statusEl.className = 'status-indicator status-error';
          statusEl.textContent = '❌ Taxa de amostragem insuficiente';
        }
      }, 2000);
    }

    function setupEventListeners(){
      document.getElementById('protocol').addEventListener('change', updateProtocolInstructions);
      document.getElementById('recordBtn').addEventListener('click', toggleRecording);
      document.getElementById('exportCsv').addEventListener('click', exportCSV);
      document.getElementById('exportJson').addEventListener('click', exportJSON);
      document.getElementById('exportReport').addEventListener('click', exportReport);
      document.getElementById('resetAnalysis').addEventListener('click', resetAnalysis);
    }

    // ===== CAPTURA =====
    function handleMotionEvent(event){
      State.eventCount++;
      const now = Date.now();

      if(State.lastEventTime){
        const dt = (now - State.lastEventTime)/1000;
        State.sampleRate = State.sampleRate*0.9 + (1/dt)*0.1;
      }
      State.lastEventTime = now;

      if(State.collecting){
        const acc = event.acceleration || event.accelerationIncludingGravity || {};
        const timestamp = (now - State.startTime)/1000;
        let value = 0;
        switch(document.getElementById('axis').value){
          case 'magnitude': value = Math.sqrt((acc.x||0)**2 + (acc.y||0)**2 + (acc.z||0)**2); break;
          case 'dominant': {
            const ax = Math.abs(acc.x||0), ay = Math.abs(acc.y||0), az = Math.abs(acc.z||0);
            value = (ax>=ay && ax>=az) ? (acc.x||0) : (ay>=az ? (acc.y||0) : (acc.z||0));
            break;
          }
          case 'x': value = acc.x||0; break;
          case 'y': value = acc.y||0; break;
          case 'z': value = acc.z||0; break;
        }
        State.times.push(timestamp);
        State.data.push(value);
        updateProgress();
      }
    }

    function toggleRecording(){ State.collecting ? stopRecording() : startRecording(); }

    function startRecording(){
      if(!State.sensorReady) return;
      State.data = []; State.times = []; State.collecting = true; State.startTime = Date.now();

      const btn = document.getElementById('recordBtn');
      const text = document.getElementById('recordText');
      const progress = document.getElementById('progressContainer');

      btn.className = 'btn btn-warning btn-full';
      text.textContent = 'Parar Coleta';
      progress.classList.remove('hidden');

      const duration = parseInt(document.getElementById('duration').value)||30;
      setTimeout(()=>{ if(State.collecting) stopRecording(); }, duration*1000);
    }

    function stopRecording(){
      State.collecting = false;
      const btn = document.getElementById('recordBtn');
      const text = document.getElementById('recordText');
      const progress = document.getElementById('progressContainer');

      btn.className = 'btn btn-success btn-full';
      text.textContent = 'Analisando...';
      btn.disabled = true;

      setTimeout(()=>{ progress.classList.add('hidden'); analyzeData(); }, 500);
    }

    function updateProgress(){
      if(!State.collecting) return;
      const duration = parseInt(document.getElementById('duration').value)||30;
      const elapsed = (Date.now() - State.startTime)/1000;
      const pct = Math.min(100, (elapsed/duration)*100);
      document.getElementById('progressBar').style.width = `${pct}%`;
      document.getElementById('progressText').textContent = `${Math.round(elapsed)}s / ${duration}s - ${State.data.length} amostras`;
    }

    // ===== QUALIDADE =====
    function updateProtocolInstructions(){
      const protocol = document.getElementById('protocol').value;
      const instructions = Protocols[protocol].instructions;
      const container = document.getElementById('protocolInstructions');
      container.innerHTML = instructions.map(i => `<div class="protocol-step">${i}</div>`).join('');
    }

    function updateQualityIndicators(){
      document.getElementById('sampleRate').textContent = `${Math.round(State.sampleRate)} Hz`;
      document.getElementById('samples').textContent = State.eventCount;
      const quality = State.sampleRate >= Config.targetSampleRate ? 'Excelente' :
                      State.sampleRate >= Config.minSampleRate ? 'Boa' : 'Baixa';
      document.getElementById('signalQuality').textContent = quality;
    }

    // ===== ANÁLISE =====
    function analyzeData(){
      if(State.data.length < 100){
        alert('Dados insuficientes para análise. Tente coletar por mais tempo.');
        resetRecordingUI(); return;
      }
      const processed = preprocessSignal(State.data);
      const spectral = performSpectralAnalysis(processed, State.sampleRate);
      const metrics = calculateTremorMetrics(spectral);
      const classification = classifyTremor(metrics);

      State.results = {
        raw: State.data, processed, spectral, metrics, classification,
        protocol: document.getElementById('protocol').value,
        timestamp: new Date().toISOString()
      };

      displayResults();
    }

    function preprocessSignal(data){
      const mean = data.reduce((s,v)=>s+v,0)/data.length;
      let detrended = data.map(v=>v-mean);
      detrended = applyBandpassFilter(detrended, State.sampleRate, Config.tremBandLow, Config.tremBandHigh);
      return detrended;
    }

    function applyBandpassFilter(data, fs, lowCut, highCut){
      const nyq = fs/2;
      const lowNorm = lowCut/nyq;
      const highNorm = highCut/nyq;
      let y = highPassFilter(data, lowNorm);
      y = lowPassFilter(y, highNorm);
      return y;
    }

    function highPassFilter(data, cutoff){
      const alpha = 1/(1+2*Math.PI*cutoff);
      const out = [data[0]];
      for(let i=1;i<data.length;i++){ out[i] = alpha*(out[i-1] + data[i] - data[i-1]); }
      return out;
    }
    function lowPassFilter(data, cutoff){
      const alpha = (2*Math.PI*cutoff) / (1 + 2*Math.PI*cutoff);
      const out = [data[0]];
      for(let i=1;i<data.length;i++){ out[i] = alpha*data[i] + (1-alpha)*out[i-1]; }
      return out;
    }

    function performSpectralAnalysis(data, fs){
      const segN = Math.max(8, Math.floor(Config.welchSegmentLength*fs)); // guarda contra N pequeno
      const overlap = Math.floor(segN*Config.welchOverlap);
      const step = Math.max(1, segN - overlap);

      let psdSum = null, nSeg = 0;

      for(let start=0; start+segN<=data.length; start+=step){
        const segment = data.slice(start, start+segN);
        const windowed = applyHanningWindow(segment);
        const mag = computeFFT(windowed);
        const psd = mag.map(v => (v*v)/(fs*segN));
        if(psdSum===null) psdSum = psd;
        else for(let i=0;i<psd.length;i++) psdSum[i]+=psd[i];
        nSeg++;
      }
      if(!nSeg){ // fallback se janela não coube
        const windowed = applyHanningWindow(data);
        const mag = computeFFT(windowed);
        psdSum = mag.map(v => (v*v)/(fs*data.length));
        nSeg = 1;
      }
      const avgPSD = psdSum.map(v=>v/nSeg);
      const freqs = new Array(avgPSD.length);
      for(let i=0;i<avgPSD.length;i++) freqs[i] = (i*fs)/(2*avgPSD.length);
      return {frequencies: freqs, psd: avgPSD};
    }

    function applyHanningWindow(data){
      const n = data.length;
      return data.map((v,i)=> v * (0.5*(1 - Math.cos(2*Math.PI*i/(n-1)))));
    }

    function computeFFT(data){
      // DFT (sem dependências) suficiente para N clínicos curtos; considere FFT otimizadas em produção.
      const n = data.length;
      const real = new Array(n/2).fill(0);
      const imag = new Array(n/2).fill(0);
      for(let k=0;k<n/2;k++){
        let r=0,i=0;
        for(let j=0;j<n;j++){
          const ang = -2*Math.PI*k*j/n;
          r += data[j]*Math.cos(ang);
          i += data[j]*Math.sin(ang);
        }
        real[k]=r; imag[k]=i;
      }
      return real.map((r,idx)=> Math.hypot(r, imag[idx]));
    }

    function calculateTremorMetrics({frequencies, psd}){
      let peakIdx = 0, peakPower = -Infinity;
      for(let i=0;i<frequencies.length;i++){
        const f = frequencies[i];
        if(f>=3 && f<=20 && psd[i]>peakPower){ peakPower = psd[i]; peakIdx = i; }
      }
      const peakFreq = frequencies[peakIdx] || 0;

      const halfMax = peakPower/2;
      let left = peakIdx, right = peakIdx;
      while(left>0 && psd[left] > halfMax) left--;
      while(right<psd.length-1 && psd[right] > halfMax) right++;
      const fwhm = (frequencies[right] - frequencies[left]) || 0;

      const totalPower = psd.reduce((s,v)=>s+v,0) || 1e-9;
      const probs = psd.map(v=>v/totalPower);
      const entropy = -probs.reduce((s,p)=> p>0 ? s + p*Math.log2(p) : s, 0);
      const peakRatio = peakPower/totalPower;
      const tsi = peakFreq ? (fwhm/peakFreq) : 0;

      let centroid = 0;
      for(let i=0;i<frequencies.length;i++) centroid += frequencies[i]*psd[i];
      centroid /= totalPower;

      return {peakFreq, peakPower, fwhm, entropy, peakRatio, tsi, centroid};
    }

    function classifyTremor(m){
      const {peakFreq, fwhm, entropy, peakRatio, tsi} = m;
      const protocol = document.getElementById('protocol').value;
      const scores = {ET:0, PD:0, DT:0, OT:0, MY:0};

      if(peakFreq>=4 && peakFreq<=12){
        scores.ET = 0.8 - Math.abs(peakFreq-7)*0.05;
        if(protocol==='postural' || protocol==='kinetic') scores.ET += 0.1;
        if(peakRatio>0.1) scores.ET += 0.1;
      }
      if(peakFreq>=3 && peakFreq<=6){
        scores.PD = 0.7 + (6-peakFreq)*0.1;
        if(protocol==='rest') scores.PD += 0.2;
        if(tsi<0.3) scores.PD += 0.1;
      }
      if(peakFreq>=3 && peakFreq<=7){
        scores.DT = 0.6;
        if(fwhm>1.5) scores.DT += 0.2;
        if(entropy>3) scores.DT += 0.1;
        if(tsi>0.4) scores.DT += 0.1;
      }
      if(peakFreq>=13 && peakFreq<=18){
        scores.OT = 0.8;
        if(protocol==='orthostatic') scores.OT += 0.2;
        if(peakRatio>0.15) scores.OT += 0.1;
      }
      if(entropy>4 || tsi>0.6){
        scores.MY = 0.5 + Math.max(0, entropy-4)*0.1;
        if(fwhm>3) scores.MY += 0.2;
      }

      const total = Math.max(0.001, Object.values(scores).reduce((s,v)=>s+v,0));
      const normalized = {};
      for(const [k,v] of Object.entries(scores)) normalized[k] = (v/total)*100;

      const topDiagnosis = Object.entries(normalized).reduce((a,b)=> a[1]>b[1]?a:b)[0];
      return {scores: normalized, topDiagnosis};
    }

    // ===== EXIBIÇÃO =====
    function displayResults(){
      const {metrics, classification} = State.results;
      document.getElementById('resultsSection').classList.remove('hidden');

      document.getElementById('peakFreq').textContent = `${metrics.peakFreq.toFixed(1)}`;
      document.getElementById('peakPower').textContent = `${metrics.peakPower.toFixed(3)}`;
      document.getElementById('fwhm').textContent = `${metrics.fwhm.toFixed(2)}`;
      document.getElementById('tremStab').textContent = `${metrics.tsi.toFixed(3)}`;
      document.getElementById('specEntropy').textContent = `${metrics.entropy.toFixed(2)}`;
      document.getElementById('peakRatio').textContent = `${metrics.peakRatio.toFixed(3)}`;

      updateClassificationBars(classification.scores);

      const explanations = {
        ET:`Pico bem definido em ${metrics.peakFreq.toFixed(1)} Hz compatível com tremor essencial. Predomina em atividade postural/cinética.`,
        PD:`Frequência de ${metrics.peakFreq.toFixed(1)} Hz em repouso sugere tremor parkinsoniano. Avaliar outros sinais motores.`,
        DT:`Espectro irregular com pico em ${metrics.peakFreq.toFixed(1)} Hz. Padrão compatível com tremor distônico.`,
        OT:`Alta frequência (${metrics.peakFreq.toFixed(1)} Hz) em ortostatismo. Típico de tremor ortostático.`,
        MY:`Distribuição espectral difusa. Características sugestivas de mioclonia ou tremor irregular.`
      };
      document.getElementById('diagnosticExplanation').innerHTML =
        `<strong>Interpretação:</strong> ${explanations[classification.topDiagnosis] || 'Padrão atípico - requer avaliação clínica adicional.'}<br>
         <em>Nota: Esta análise é uma ferramenta auxiliar. O diagnóstico final deve sempre considerar o contexto clínico completo.</em>`;

      plotTimeSignal();
      plotPSD();
      resetRecordingUI();
    }

    function updateClassificationBars(scores){
      const map = {ET:'et', PD:'pd', DT:'dt', OT:'ot', MY:'my'};
      Object.entries(map).forEach(([k,prefix])=>{
        const val = Math.round(scores[k]||0);
        const fill = document.getElementById(`${prefix}Fill`);
        const label = document.getElementById(`${prefix}Percent`);
        if(fill) fill.style.width = `${val}%`;
        if(label) label.textContent = `${val}%`;
      });
    }

    function plotTimeSignal(){
      const canvas = document.getElementById('timeChart');
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      ctx.clearRect(0,0,rect.width,rect.height);

      const data = State.results.processed;
      const times = State.times;
      const pad = 40, w = rect.width - 2*pad, h = rect.height - 2*pad;

      const tmin = times[0] ?? 0;
      const tmax = times[times.length-1] ?? 1;
      const ymin = Math.min(...data);
      const ymax = Math.max(...data);
      const yr = (ymax - ymin) || 1;

      ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
      for(let i=0;i<=5;i++){
        const y = pad + i*h/5; ctx.beginPath(); ctx.moveTo(pad,y); ctx.lineTo(rect.width-pad,y); ctx.stroke();
        const x = pad + i*w/5; ctx.beginPath(); ctx.moveTo(x,pad); ctx.lineTo(x,rect.height-pad); ctx.stroke();
      }

      ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2; ctx.beginPath();
      for(let i=0;i<times.length;i++){
        const x = pad + ((times[i]-tmin)/(tmax-tmin || 1))*w;
        const y = pad + (1 - (data[i]-ymin)/yr)*h;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();

      ctx.fillStyle = '#6b7280'; ctx.font = '12px system-ui';
      ctx.fillText('Tempo (s)', rect.width/2 - 30, rect.height - 10);
      ctx.save(); ctx.translate(15, rect.height/2); ctx.rotate(-Math.PI/2); ctx.fillText('Aceleração (g)', -40, 0); ctx.restore();
    }

    function plotPSD(){
      const canvas = document.getElementById('psdChart');
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      ctx.clearRect(0,0,rect.width,rect.height);

      const {frequencies, psd} = State.results.spectral;
      const pad = 40, w = rect.width - 2*pad, h = rect.height - 2*pad;

      const maxFreq = 30;
      const idx = frequencies.findIndex(f => f > maxFreq);
      const maxIdx = (idx === -1) ? frequencies.length : idx;
      const f = frequencies.slice(0, maxIdx);
      const P = psd.slice(0, maxIdx);
      const Pmax = Math.max(...P) || 1;

      ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
      for(let i=0;i<=5;i++){
        const y = pad + i*h/5; ctx.beginPath(); ctx.moveTo(pad,y); ctx.lineTo(rect.width-pad,y); ctx.stroke();
        const x = pad + i*w/5; ctx.beginPath(); ctx.moveTo(x,pad); ctx.lineTo(x,rect.height-pad); ctx.stroke();
      }

      ctx.strokeStyle = '#10b981'; ctx.lineWidth = 2; ctx.beginPath();
      for(let i=0;i<f.length;i++){
        const x = pad + (f[i]/maxFreq)*w;
        const y = pad + (1 - (P[i]/Pmax))*h;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();

      const peakF = State.results.metrics.peakFreq;
      const pIdx = f.findIndex(x => x >= peakF);
      if(pIdx >= 0){
        const x = pad + (peakF/maxFreq)*w;
        const y = pad + (1 - (P[pIdx]/Pmax))*h;
        ctx.fillStyle = '#ef4444';
        ctx.beginPath(); ctx.arc(x,y,4,0,2*Math.PI); ctx.fill();
        ctx.fillStyle = '#ef4444'; ctx.font = '11px system-ui';
        ctx.fillText(`${peakF.toFixed(1)} Hz`, x+8, y-5);
      }

      ctx.fillStyle = '#6b7280'; ctx.font = '12px system-ui';
      ctx.fillText('Frequência (Hz)', rect.width/2 - 40, rect.height - 10);
      ctx.save(); ctx.translate(15, rect.height/2); ctx.rotate(-Math.PI/2); ctx.fillText('PSD (g²/Hz)', -30, 0); ctx.restore();
    }

    // ===== EXPORTAÇÃO / RESET =====
    function resetRecordingUI(){
      const btn = document.getElementById('recordBtn');
      const text = document.getElementById('recordText');
      btn.className = 'btn btn-primary btn-full'; btn.disabled = false; text.textContent = 'Iniciar Nova Coleta';
    }

    function exportCSV(){
      if(!State.results) return;
      const protocol = document.getElementById('protocol').value;
      const patientId = document.getElementById('patientId').value || 'N/A';
      let csv = `# TremorAnalyzer - Dados de Análise\n`;
      csv += `# Protocolo: ${Protocols[protocol].name}\n`;
      csv += `# Paciente: ${patientId}\n`;
      csv += `# Data: ${new Date().toLocaleString()}\n`;
      csv += `# Taxa de Amostragem: ${State.sampleRate.toFixed(1)} Hz\n#\n`;
      csv += `Tempo_s,Aceleracao_g,Aceleracao_Filtrada_g\n`;
      for(let i=0;i<State.times.length;i++){
        csv += `${(State.times[i]??0).toFixed(6)},${(State.raw?.[i]??State.data[i]).toFixed(6)},${(State.results.processed[i]??0).toFixed(6)}\n`;
      }
      downloadFile(csv, `tremor_analysis_${getTimestamp()}.csv`, 'text/csv');
    }

    function exportJSON(){
      if(!State.results) return;
      const exportData = {
        metadata:{
          timestamp:new Date().toISOString(),
          protocol:document.getElementById('protocol').value,
          patientId:document.getElementById('patientId').value||null,
          clinicalNotes:document.getElementById('clinicalNotes').value||null,
          sampleRate:State.sampleRate,
          duration:(State.times[State.times.length-1]??0) - (State.times[0]??0),
          sampleCount:State.data.length
        },
        rawData:{times:State.times, acceleration:State.data},
        processedData:{filtered:State.results.processed},
        spectral:State.results.spectral,
        metrics:State.results.metrics,
        classification:State.results.classification
      };
      downloadFile(JSON.stringify(exportData,null,2), `tremor_data_${getTimestamp()}.json`, 'application/json');
    }

    function exportReport(){
      if(!State.results) return;
      const protocol = Protocols[document.getElementById('protocol').value];
      const {metrics, classification} = State.results;
      const patientId = document.getElementById('patientId').value || 'N/A';
      const clinicalNotes = document.getElementById('clinicalNotes').value || 'Nenhuma observação registrada.';
      const report =
`RELATÓRIO DE ANÁLISE DE TREMOR
TremorAnalyzer - Sistema Clínico

===========================================
INFORMAÇÕES DA SESSÃO
===========================================
Data/Hora: ${new Date().toLocaleString()}
Paciente: ${patientId}
Protocolo: ${protocol.name}
Duração: ${((State.times[State.times.length-1]??0)-(State.times[0]??0)).toFixed(1)} s
Taxa de Amostragem: ${State.sampleRate.toFixed(1)} Hz
Amostras Coletadas: ${State.data.length}

===========================================
MÉTRICAS ESPECTRAIS
===========================================
Frequência de Pico: ${metrics.peakFreq.toFixed(1)} Hz
Potência do Pico: ${metrics.peakPower.toFixed(4)} g²/Hz
FWHM (Largura): ${metrics.fwhm.toFixed(2)} Hz
Índice de Estabilidade (TSI): ${metrics.tsi.toFixed(3)}
Entropia Espectral: ${metrics.entropy.toFixed(2)}
Razão Pico/Total: ${metrics.peakRatio.toFixed(3)}
Centroide Espectral: ${metrics.centroid.toFixed(1)} Hz

===========================================
CLASSIFICAÇÃO DIFERENCIAL
===========================================
Tremor Essencial: ${Math.round(classification.scores.ET)}%
Tremor Parkinsoniano: ${Math.round(classification.scores.PD)}%
Tremor Distônico: ${Math.round(classification.scores.DT)}%
Tremor Ortostático: ${Math.round(classification.scores.OT)}%
Mioclonia: ${Math.round(classification.scores.MY)}%

Diagnóstico Mais Provável: ${classification.topDiagnosis}

===========================================
OBSERVAÇÕES CLÍNICAS
===========================================
${clinicalNotes}

===========================================
INTERPRETAÇÃO
===========================================
Esta análise quantitativa é baseada em características espectrais do sinal de aceleração coletado durante o protocolo especificado. Os resultados devem ser interpretados no contexto clínico completo do paciente.
A classificação diferencial é auxiliar e não substitui a avaliação neurológica.
`;
      downloadFile(report, `relatorio_tremor_${getTimestamp()}.txt`, 'text/plain');
    }

    function resetAnalysis(){
      if(!confirm('Isso irá apagar todos os dados coletados. Deseja continuar?')) return;
      State.data = []; State.times = []; State.results = null;
      document.getElementById('resultsSection').classList.add('hidden');
      document.getElementById('patientId').value = '';
      document.getElementById('clinicalNotes').value = '';
      resetRecordingUI();
    }

    function downloadFile(content, filename, mime){
      const blob = new Blob([content], {type:mime});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function getTimestamp(){ return new Date().toISOString().replace(/[:.]/g,'-').slice(0,19); }
    function isSecureContext(){ return location.protocol==='https:' || location.hostname==='localhost' || location.hostname==='127.0.0.1'; }

    // ===== PWA (SW por Blob) =====
    if('serviceWorker' in navigator){
      const swCode = `
        self.addEventListener('install',e=>self.skipWaiting());
        self.addEventListener('activate',e=>e.waitUntil(self.clients.claim()));
        self.addEventListener('fetch',e=>{
          if(e.request.url.startsWith(self.location.origin)){
            e.respondWith(fetch(e.request).catch(()=>new Response('Aplicação offline',{status:503,statusText:'Service Unavailable'})));
          }
        });
      `;
      const blob = new Blob([swCode], {type:'text/javascript'});
      const swUrl = URL.createObjectURL(blob);
      navigator.serviceWorker.register(swUrl).catch(()=>{});
    }
  </script>
</body>
</html>
